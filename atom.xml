<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拾忆的技术博客</title>
  
  <subtitle>拾忆的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-23T06:40:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>拾忆</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS runtime 总结（七）---- 实际使用</title>
    <link href="http://yoursite.com/2018/03/22/blog12/"/>
    <id>http://yoursite.com/2018/03/22/blog12/</id>
    <published>2018-03-22T02:50:14.000Z</published>
    <updated>2018-03-23T06:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>这里我以工程中使用到一些runtime相关的代码作为例子，供大家参考和使用</p></blockquote><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><p>先给NSObject加个分类，封装下方法交换，方便后面使用</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog12pic/1.png" alt="pic1"></p><blockquote><p>下面总结的方法，大家可自行去尝试下效果</p></blockquote><h2 id="给button增加个防止连续重复点击的时间差"><a href="#给button增加个防止连续重复点击的时间差" class="headerlink" title="给button增加个防止连续重复点击的时间差"></a>给button增加个防止连续重复点击的时间差</h2><p>在 <code>&quot;UIButton+Swiz.h&quot;</code> 中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIButton</span> (<span class="title">Swiz</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//点击间隔</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> timeInterval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于设置单个按钮是否需要timeInterval </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isIgnore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在 <code>&quot;UIButton+Swiz.m&quot;</code> 中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"UIButton+Swiz.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"NSObject+Swiz.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define defaultInterval 0.3</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">Swiz</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> methodSwizzlingWithOriginalSelector:<span class="keyword">@selector</span>(sendAction:to:forEvent:) bySwizzledSelector:<span class="keyword">@selector</span>(sure_SendAction:to:forEvent:)];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sure_SendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isIgnore) &#123;</span><br><span class="line">        <span class="comment">//不需要timeInterval 被hook</span></span><br><span class="line">        [<span class="keyword">self</span> sure_SendAction:action to:target forEvent:event];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class) isEqualToString:<span class="string">@"UIButton"</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.timeInterval = <span class="keyword">self</span>.timeInterval == <span class="number">0</span> ? defaultInterval : <span class="keyword">self</span>.timeInterval;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isIgnoreEvent) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.timeInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(resetState) withObject:<span class="literal">nil</span> afterDelay:<span class="keyword">self</span>.timeInterval];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.isIgnoreEvent = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> sure_SendAction:action to:target forEvent:event];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)resetState &#123;</span><br><span class="line">    [<span class="keyword">self</span> setIsIgnoreEvent:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - runtime动态绑定一个isIgnoreEvent属性</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isIgnoreEvent &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) boolValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setIsIgnoreEvent:(<span class="built_in">BOOL</span>)isIgnoreEvent &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(isIgnoreEvent), @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - runtime动态绑定自定义的两个属性</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)timeInterval &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) doubleValue];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setTimeInterval:(<span class="built_in">NSTimeInterval</span>)timeInterval &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(timeInterval), @(timeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isIgnore &#123;</span><br><span class="line">    <span class="comment">//_cmd == @select(isIgnore); 和set方法里一致</span></span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) boolValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setIsIgnore:(<span class="built_in">BOOL</span>)isIgnore &#123;</span><br><span class="line">    <span class="comment">// 注意BOOL类型 需要用OBJC_ASSOCIATION_RETAIN_NONATOMIC 不要用错，否则set方法会赋值出错</span></span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(isIgnore), @(isIgnore), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="给button增加点击范围"><a href="#给button增加点击范围" class="headerlink" title="给button增加点击范围"></a>给button增加点击范围</h2><p>在 <code>&quot;UIButton+Swiz.h&quot;</code> 中加入：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//设置超出自身范围的额外点击区域</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UIEdgeInsets</span> touchAreaInsets;</span><br></pre></td></tr></table></figure><p>在 <code>&quot;UIButton+Swiz.m&quot;</code> 中加入：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">UIEdgeInsets</span>)touchAreaInsets &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) <span class="built_in">UIEdgeInsetsValue</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setTouchAreaInsets:(<span class="built_in">UIEdgeInsets</span>)touchAreaInsets &#123;</span><br><span class="line">    <span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithUIEdgeInsets:touchAreaInsets];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(touchAreaInsets), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIEdgeInsets</span> touchAreaInsets = <span class="keyword">self</span>.touchAreaInsets;</span><br><span class="line">    <span class="built_in">CGRect</span> bounds = <span class="keyword">self</span>.bounds;</span><br><span class="line">    bounds = <span class="built_in">CGRectMake</span>(bounds.origin.x - touchAreaInsets.left, bounds.origin.y - touchAreaInsets.top, bounds.size.width + touchAreaInsets.left + touchAreaInsets.right, bounds.size.height + touchAreaInsets.top + touchAreaInsets.bottom);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(bounds, point);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里我以工程中使用到一些runtime相关的代码作为例子，供大家参考和使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime 总结（六）---- 使用场景</title>
    <link href="http://yoursite.com/2018/03/21/iOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89----%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2018/03/21/iOS runtime 总结（六）---- 使用场景/</id>
    <published>2018-03-21T02:49:48.000Z</published>
    <updated>2018-03-21T09:34:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用KVC进行赋值实现json转model"><a href="#利用KVC进行赋值实现json转model" class="headerlink" title="利用KVC进行赋值实现json转model"></a>利用KVC进行赋值实现json转model</h2><p>原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。<br>核心方法：在NSObject的分类中添加方法</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/1.png" alt="picture1"></p><h2 id="一键序列化"><a href="#一键序列化" class="headerlink" title="一键序列化"></a>一键序列化</h2><p>原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。<br>核心方法：在Model的基类中重写方法：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/2.png" alt="picture2"></p><h2 id="访问私有变量"><a href="#访问私有变量" class="headerlink" title="访问私有变量"></a>访问私有变量</h2><p>我们知道，OC中没有真正意义上的私有变量和方法，要让成员变量私有，要放在m文件中声明，不对外暴露。如果我们知道这个成员变量的名称，可以通过runtime获取成员变量，再通过getIvar来获取它的值。方法：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/13.png" alt="picture13"></p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/12.png" alt="picture12"></p><h2 id="修改私有变量的值"><a href="#修改私有变量的值" class="headerlink" title="修改私有变量的值"></a>修改私有变量的值</h2><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/10.png" alt="picture10"></p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/11.png" alt="picture11"></p><h2 id="给分类添加公共属性"><a href="#给分类添加公共属性" class="headerlink" title="给分类添加公共属性"></a>给分类添加公共属性</h2><p>这是最常用的一个模式，通常我们会在类声明里面添加属性，但是出于某些需求（如前言描述的情况），我们需要在分类里添加一个或多个属性的话，编译器就会报错，这个问题的解决方案就是使用runtime的关联对象</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/5.png" alt="picture5"></p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/6.png" alt="picture6"></p><p>这样就可以使用这个属性了</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/7.png" alt="picture7"></p><h2 id="「方法替换」常规写法"><a href="#「方法替换」常规写法" class="headerlink" title="「方法替换」常规写法"></a>「方法替换」常规写法</h2><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog11pic/9.png" alt="picture9"></p><p>上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。</p><blockquote><p>这里有现成的方案：一个基于 swizzling method 的开源框架 <a href="https://github.com/steipete/Aspects" target="_blank" rel="noopener">Aspects</a> 。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;利用KVC进行赋值实现json转model&quot;&gt;&lt;a href=&quot;#利用KVC进行赋值实现json转model&quot; class=&quot;headerlink&quot; title=&quot;利用KVC进行赋值实现json转model&quot;&gt;&lt;/a&gt;利用KVC进行赋值实现json转model&lt;/
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime 总结（五）---- 消息转发</title>
    <link href="http://yoursite.com/2018/03/16/iOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89----%20%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91/"/>
    <id>http://yoursite.com/2018/03/16/iOS runtime 总结（五）---- 消息转发/</id>
    <published>2018-03-16T08:01:00.000Z</published>
    <updated>2018-03-16T08:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h2><blockquote><p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式 <code>[receiver message]</code> 转化为一个消息函数的调用，即 <code>objc_msgSend</code>。</p></blockquote><blockquote><p>当消息发送给一个对象时，<code>objc_msgSend</code> 通过对象的 <code>isa</code> 指针获取到类的结构体，然后在方法分发表里面查找方法的<code>selector</code>。如果没有找到 <code>selector</code> ，则通过<code>objc_msgSend</code> 结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的 <code>selector</code>。依此，会一直沿着类的继承体系到达 <code>NSObject</code> 类。一旦定位到 <code>selector</code> ，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到 <code>selector</code>，则会走<strong>消息转发</strong>流程。</p></blockquote><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>默认情况下，如果是以 <code>[object message]</code> 的方式调用方法，如果 <code>object</code> 无法响应 <code>message</code> 消息时，编译器会报错。但如果是以 <code>perform…</code> 的形式来调用，则需要等到运行时才能确定 <code>object</code> 是否能接收 <code>message</code> 消息。如果不能，则程序崩溃。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。</p><p><strong>消息转发机制的步骤：</strong></p><h3 id="1-动态方法解析"><a href="#1-动态方法解析" class="headerlink" title="1. 动态方法解析"></a>1. 动态方法解析</h3><p>对象在接收到未知的消息时，首先会调用所属类的类方法 <code>+resolveInstanceMethod:</code> (实例方法)或者 <code>+resolveClassMethod:</code> (类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过 <code>class_addMethod</code> 函数动态添加到类里面就可以了。</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/1.png" alt="picture1"></p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/2.png" alt="picture2"></p><p>测试一下：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/3.png" alt="picture3"></p><blockquote><p>打印结果：</p><p>2018-03-16 16:14:04.104890+0800 runtimeDemo1[27033:7983789] 123456</p></blockquote><h3 id="2-备用接收者"><a href="#2-备用接收者" class="headerlink" title="2. 备用接收者"></a>2. 备用接收者</h3><p>如果在上一步动态方法解析没有处理或无法处理消息，则Runtime会继续调方法：<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> ，如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/4.png" alt="picture4"></p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/5.png" alt="picture5"></p><p>在MyClass.m中添加如下方法：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/6.png" alt="picture6"></p><p>测试一下：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/7.png" alt="picture7"></p><p>打印结果：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/8.png" alt="picture8"></p><h3 id="3-完整消息转发"><a href="#3-完整消息转发" class="headerlink" title="3. 完整消息转发"></a>3. 完整消息转发</h3><p>如果在上一步备用接收者还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用方法：<code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code> ，对象会创建一个表示消息的 <code>NSInvocation</code> 对象，把与尚未处理的消息有关的全部细节都封装在 <code>anInvocation</code> 中，包括selector，目标(target)和参数。我们可以在 <code>forwardInvocation</code> 方法中选择将消息转发给其它对象。</p><p>forwardInvocation:方法的实现有两个任务： </p><ul><li>定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。 </li><li>使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li></ul><p>还有一个很重要的问题，我们必须重写以下方法：<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code> ,消息转发机制使用从这个方法中获取的信息来创建 <code>NSInvocation</code> 对象。因此我们必须重写这个方法，为给定的 <code>selector</code> 提供一个合适的方法签名。</p><p>向OtherClass.m中添加如下方法：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/9.png" alt="picture9"></p><p>向MyClass.m中添加如下方法：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/10.png" alt="picture10"></p><p>测试一下：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog10pic/11.png" alt="picture11"></p><blockquote><p>打印结果：</p><p>2018-03-16 16:40:38.493453+0800 runtimeDemo1[27044:7993120] 321</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法调用流程&quot;&gt;&lt;a href=&quot;#方法调用流程&quot; class=&quot;headerlink&quot; title=&quot;方法调用流程&quot;&gt;&lt;/a&gt;方法调用流程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime 总结（四）---- Associative介绍及使用</title>
    <link href="http://yoursite.com/2018/03/16/iOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89----%20Associative%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/16/iOS runtime 总结（四）---- Associative介绍及使用/</id>
    <published>2018-03-16T06:10:57.000Z</published>
    <updated>2018-03-16T06:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Associative概念"><a href="#一、Associative概念" class="headerlink" title="一、Associative概念"></a>一、Associative概念</h2><blockquote><p>在日常的开发中，objective-c有两个扩展的机制：category和associative。而我们日常使用中百分之90都是使用的category作为日常的扩展方法，但是这个方法有很大的局限性：因为它并不能扩展属性。于是我们就需要借助于另外一个属性的扩展机制：associative</p></blockquote><h2 id="二、Associative介绍及使用"><a href="#二、Associative介绍及使用" class="headerlink" title="二、Associative介绍及使用"></a>二、Associative介绍及使用</h2><p><strong>associative</strong>的原理就是把两个对象互相的捆绑、关联起来，使的其中的一个对象成为另外一个对象的一部分。并且我们可以不用使用修改类的定义而为其对象增加储存空间。这就有一个非常大的好处：在我们无法访问到类的源码的时候或者是考虑到二进制兼容性的时候是非常有用的。因为这允许开发者对已经存在的类在扩展中添加自定义的属性，这几乎弥补了Objective-C最大的缺点。</p><p>在使用上，associative是基于key的。所以，我们可以为任何的对象增加无数个不同key的associative，每个都使用上不同的key就好了。并且associative是可以保证能被关联的对象在关联对象的整个生命周期都是可用。</p><p>注意：由于正常的扩展是不可以扩展属性的，所以我们在使用associative的时候需要导入 <code>#import &lt;objc/runtime.h&gt;</code> 来实现</p><h3 id="1-associative方法"><a href="#1-associative方法" class="headerlink" title="1. associative方法"></a>1. associative方法</h3><p>其中有3个方法：</p><ul><li><p>objc_setAssociatedObject</p></li><li><p>objc_getAssociatedObject</p></li><li><p>objc_removeAssociatedObjects</p></li></ul><p>分别表示设置关联，取得关联，移除关联</p><h3 id="2-创建associative"><a href="#2-创建associative" class="headerlink" title="2. 创建associative"></a>2. 创建associative</h3><p>创建<strong>associative</strong>使用的是：<code>objc_setAssociatedObject</code> 。它把一个对象与另外一个对象进行关联。该函数需要四个参数：</p><ul><li>object（源对象）: The source object for the association.</li><li>key（关键字）: The key for the association.</li><li>value（关联的对象） :The value to associate with the key key for object. Pass nil to clear an existing association.</li><li>policy（关联策略） :The policy for the association. For possible values, see “Associative Object Behaviors.”</li></ul><h4 id="2-1-key关键字"><a href="#2-1-key关键字" class="headerlink" title="2.1 key关键字"></a>2.1 key关键字</h4><p>关于前两个函数中的 <strong>key</strong> 值是我们需要重点关注的一个点，这个 <strong>key</strong> 值必须保证是一个对象级别（为什么是对象级别？看完下面的章节你就会明白了）的唯一常量。一般来说，有以下三种推荐的 <strong>key</strong> 值：</p><ul><li>声明 <code>static char kAssociatedObjectKey</code> ，使用 <code>&amp;kAssociatedObjectKey</code> 作为 <strong>key</strong> 值。</li><li>声明 <code>static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey</code> ，使用 <code>kAssociatedObjectKey</code> 作为 <strong>key</strong> 值。</li><li>用 <code>selector</code> ，使用 <code>getter</code> 方法的名称作为 <strong>key</strong> 值。</li></ul><p>关键字是一个<code>void</code>类型的指针。每一个关联的关键字必须是唯一的。通常都是会采用静态变量来作为关键字，但是其中3个方法中一般1，2基本可以忽略，只使用第三种就好了。因为这样可以优雅地解决了计算科学中的两大世界难题之一：命名（另一难题是缓存失效 ）。</p><h4 id="2-2-关联策略"><a href="#2-2-关联策略" class="headerlink" title="2.2 关联策略"></a>2.2 关联策略</h4><p>关联策略表明了相关的对象是通过赋值，保留引用还是复制的方式进行关联的；还有这种关联是原子的还是非原子的。这里的关联策略和声明属性时的很类似。这种关联策略是通过使用预先定义好的常量来表示的。</p><p>根据上面引入的文档可以看出属性可以根据定义在枚举类型 objc_AssociationPolicy 上的行为被关联在对象上。 其中有5种枚举值:</p><table><thead><tr><th style="text-align:left">Behavior（枚举值）</th><th style="text-align:left">@property Equivalent（等同于属性）</th><th style="text-align:left">Description（解释）</th></tr></thead><tbody><tr><td style="text-align:left"><code>OBJC_ASSOCIATION_ASSIGN</code></td><td style="text-align:left"><code>@property (assign)</code> 或 <code>@property (unsafe_unretained)</code></td><td style="text-align:left">指定一个关联对象的弱引用</td></tr><tr><td style="text-align:left"><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code></td><td style="text-align:left"><code>@property (nonatomic, strong)</code></td><td style="text-align:left">指定一个关联对象的强引用，不能被原子化使用</td></tr><tr><td style="text-align:left"><code>OBJC_ASSOCIATION_COPY_NONATOMIC</code></td><td style="text-align:left"><code>@property (nonatomic, copy)</code></td><td style="text-align:left">指定一个关联对象的copy引用，不能被原子化使用</td></tr><tr><td style="text-align:left"><code>OBJC_ASSOCIATION_RETAIN</code></td><td style="text-align:left"><code>@property (atomic, strong)</code></td><td style="text-align:left">指定一个关联对象的强引用，能被原子化使用</td></tr><tr><td style="text-align:left"><code>OBJC_ASSOCIATION_COPY</code></td><td style="text-align:left"><code>@property (atomic, copy)</code></td><td style="text-align:left">指定一个关联对象的copy引用，能被原子化使用</td></tr></tbody></table><p>以 <code>OBJC_ASSOCIATION_ASSIGN</code> 类型关联在对象上的弱引用不代表0 <code>retian</code> 的 <code>weak</code> 弱引用，行为上更像 <code>unsafe_unretained</code> 属性，所以当在你的视线中调用<code>weak</code> 的关联对象时要相当小心</p><blockquote><p>根据WWDC 2011, Session 322发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的object_dispose() 方法中释放</p></blockquote><p>下面以给Person的类别增加一个sonName的属性为例：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog9pic/1.png" alt="picture1"></p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog9pic/2.png" alt="picture2"></p><p>测试一下:</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog9pic/3.png" alt="picture3"></p><blockquote><p>打印结果：</p><p>2018-03-16 14:45:19.138287+0800 runtimeDemo1[26986:7959679] John === Bird</p></blockquote><p>断开或者说是删除 <code>associative</code> 是 <code>associative</code> 中3个方法中最不常用的一个方法，可以说基本上都不会使用。因为它会断开所有的 <code>associative</code> 关联</p><blockquote><p>此函数的主要目的是在“初试状态”时方便地返回一个对象。你不应该用这个函数来删除对象的属性，因为可能会导致其他客户对其添加的属性也被移除了。</p><p>规范的方法是：调用 objc_setAssociatedObject 方法并传入一个 nil 值来清除一个关联。</p></blockquote><h3 id="3-消息（Message）"><a href="#3-消息（Message）" class="headerlink" title="3. 消息（Message）"></a>3. 消息（Message）</h3><p>在面向对象编程中，对象调用方法叫做发送消息。在编译时，应用的源代码就会被编将对象发送消息转换成runtime的 <code>objc_msgSend</code> 函数调用</p><p><code>[receiver message];</code> </p><p>在编译时会转换成类似这样的函数调用：</p><p><code>id objc_msgSend(id self, SEL op, ...)</code></p><p>我们是通过编译器来自动转换成运行时代码时，它会根据类型自动转换成下面的其它一个函数：</p><ul><li><strong>objc_msgSend：</strong> 其它普通的消息都会通过该函数来发送</li><li><strong>objc_msgSend_stret：</strong> 消息中需要有数据结构作为返回值时，会通过该函数来发送消息并接收返回值</li><li><strong>objc_msgSendSuper：</strong> 与objc_msgSend函数类似，只是它把消息发送给父类实例</li><li><strong>objc_msgSendSuper_stret：</strong> 与objc_msgSend_stret函数类似，只是它把消息发送给父类实例并接收数组结构作为返回值</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Associative概念&quot;&gt;&lt;a href=&quot;#一、Associative概念&quot; class=&quot;headerlink&quot; title=&quot;一、Associative概念&quot;&gt;&lt;/a&gt;一、Associative概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在日常的开
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime 总结（三）---- 方法调用示例</title>
    <link href="http://yoursite.com/2018/03/16/iOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89----%20%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2018/03/16/iOS runtime 总结（三）---- 方法调用示例/</id>
    <published>2018-03-16T02:19:10.000Z</published>
    <updated>2018-03-16T06:09:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取对象所有属性名"><a href="#获取对象所有属性名" class="headerlink" title="获取对象所有属性名"></a>获取对象所有属性名</h2><p>以创建一个Person类为例，进行示例，通过 <code>class_copyPropertyList</code> 方法获取所有的属性名称</p><blockquote><p>创建个Person类 </p></blockquote><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/1.png" alt="picture1"></p><blockquote><p>获取类的所有属性名放到数组中</p></blockquote><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/2.png" alt="picture2"></p><blockquote><p>测试一下结果</p></blockquote><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/3.png" alt="picture3"></p><blockquote><p>打印结果：</p><p>2018-03-16 10:56:45.165053+0800 runtimeDemo1[26762:7882820] classSize = 48<br>2018-03-16 10:56:45.165662+0800 runtimeDemo1[26762:7882820] propertyName == name<br>2018-03-16 10:56:45.165716+0800 runtimeDemo1[26762:7882820] propertyName == array<br>2018-03-16 10:56:45.165760+0800 runtimeDemo1[26762:7882820] propertyName == age<br>2018-03-16 10:56:45.165802+0800 runtimeDemo1[26762:7882820] propertyName == sex</p></blockquote><hr><blockquote><p>注意：上面提到的 <code>objc_property_t</code> 是一个结构体指针 <code>objc_property *</code>，因此我们声明的 <code>properties</code> 就是二维指针。所以在使用完毕以后，一定要释放内存，否则会造成内存泄露。并且由于runtime使用的是C语言的API，所以我们也需要使用C语言释放内存的方法：<code>free</code>。</p></blockquote><h2 id="获取对象的所有属性名和属性值"><a href="#获取对象的所有属性名和属性值" class="headerlink" title="获取对象的所有属性名和属性值"></a>获取对象的所有属性名和属性值</h2><p>对于获取对象的所有属性名，在上面的-allProperties方法已经可以拿到了，但是并没有处理获取属性值，下面的方法就是可以获取属性名和属性值，将属性名作为key，属性值作为value</p><p>获取类的所有属性名和属性值放到字典中</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/4.png" alt="picture4"></p><p>测试一下：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/5.png" alt="picture5"></p><blockquote><p>打印结果：</p><p>2018-03-16 11:29:35.840436+0800 runtimeDemo1[26811:7896171] propertyName == name == propertyValue: John<br>2018-03-16 11:29:35.841046+0800 runtimeDemo1[26811:7896171] propertyName == age == propertyValue: 8<br>2018-03-16 11:29:35.841134+0800 runtimeDemo1[26811:7896171] propertyName == sex == propertyValue: 0</p></blockquote><hr><h2 id="获取对象的所有方法名"><a href="#获取对象的所有方法名" class="headerlink" title="获取对象的所有方法名"></a>获取对象的所有方法名</h2><blockquote><p>通过class_copyMethodList方法就可以获取所有的方法。并且我们知道，每一个属性都会自动生成一个成员变量和setter以及getter方法</p></blockquote><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/6.png" alt="picture6"></p><p>测试一下：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/7.png" alt="picture7"></p><blockquote><p>打印结果：</p><p>2018-03-16 11:55:37.736846+0800 runtimeDemo1[26834:7903407] 方法名：allPropertyNamesAndValues,参数个数： 2<br>2018-03-16 11:55:37.736944+0800 runtimeDemo1[26834:7903407] 方法名：setAge:,参数个数： 3<br>2018-03-16 11:55:37.737014+0800 runtimeDemo1[26834:7903407] 方法名：age,参数个数： 2<br>2018-03-16 11:55:37.737096+0800 runtimeDemo1[26834:7903407] 方法名：allMethods,参数个数： 2<br>2018-03-16 11:55:37.737167+0800 runtimeDemo1[26834:7903407] 方法名：.cxx_destruct,参数个数： 2<br>2018-03-16 11:55:37.737239+0800 runtimeDemo1[26834:7903407] 方法名：setName:,参数个数： 3<br>2018-03-16 11:55:37.737305+0800 runtimeDemo1[26834:7903407] 方法名：name,参数个数： 2<br>2018-03-16 11:55:37.737370+0800 runtimeDemo1[26834:7903407] 方法名：array,参数个数： 2<br>2018-03-16 11:55:37.737442+0800 runtimeDemo1[26834:7903407] 方法名：setArray:,参数个数： 3<br>2018-03-16 11:55:37.737508+0800 runtimeDemo1[26834:7903407] 方法名：allProperties,参数个数： 2<br>2018-03-16 11:55:37.737727+0800 runtimeDemo1[26834:7903407] 方法名：setSex:,参数个数： 3<br>2018-03-16 11:55:37.737812+0800 runtimeDemo1[26834:7903407] 方法名：sex,参数个数： 2</p></blockquote><p>我们发现参数个数不匹配，比如 <code>allPropertyNamesAndValues</code> 方法，参数个数应该为0，但实际打印结果为2。根据打印结果可知，无参数时，值就已经是2了。这个在后面会详细讲解。</p><h2 id="获取对象的成员变量名称"><a href="#获取对象的成员变量名称" class="headerlink" title="获取对象的成员变量名称"></a>获取对象的成员变量名称</h2><p>要获取对象的成员变量，可以通过class_copyIvarList方法来获取，通过ivar_getName来获取成员变量的名称。并且我们知道，每一个属性都会自动生成一个成员变量和setter以及getter方法</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/8.png" alt="picture8"></p><p>测试一下：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/9.png" alt="picture9"></p><blockquote><p>打印结果：</p><p>2018-03-16 13:56:34.321855+0800 runtimeDemo1[26959:7944606] varName == _variableString<br>2018-03-16 13:56:34.322483+0800 runtimeDemo1[26959:7944606] varName == _sex<br>2018-03-16 13:56:34.322550+0800 runtimeDemo1[26959:7944606] varName == _name<br>2018-03-16 13:56:34.322596+0800 runtimeDemo1[26959:7944606] varName == _array<br>2018-03-16 13:56:34.322699+0800 runtimeDemo1[26959:7944606] varName == _age</p></blockquote><hr><h2 id="运行时发消息"><a href="#运行时发消息" class="headerlink" title="运行时发消息"></a>运行时发消息</h2><p>iOS中，可以在运行时发送消息，让接收消息者执行对应的动作。可以使用 <code>objc_msgSend</code> 方法，发送消息。因为 <code>objc_msgSend</code> 是因为只有对象才能发送消息，所以肯定是以objc开头的。</p><p>另外：使用运行时发送消息前，必须导入 <code>#import &lt;objc/message.h&gt;</code></p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/10.png" alt="picture10"></p><p>这样就等于把 <code>[p allMethods]</code> 这个方法用底层的方法表示出来，其实 <code>[p allMethods]</code> 也会转成这句代码。此时你会发现很尴尬的一个现象是：编译器会报错。</p><p>问题出在：期望的参数为空，但是实际上是有2个参数的。所以我们需要来关闭严格检查来解决这个问题。</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/11.png" alt="picture11"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取对象所有属性名&quot;&gt;&lt;a href=&quot;#获取对象所有属性名&quot; class=&quot;headerlink&quot; title=&quot;获取对象所有属性名&quot;&gt;&lt;/a&gt;获取对象所有属性名&lt;/h2&gt;&lt;p&gt;以创建一个Person类为例，进行示例，通过 &lt;code&gt;class_copyPro
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime 总结（二）---- 主要函数</title>
    <link href="http://yoursite.com/2018/03/16/iOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89----%20%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/03/16/iOS runtime 总结（二）---- 主要函数/</id>
    <published>2018-03-16T01:36:50.000Z</published>
    <updated>2018-03-16T09:10:17.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>这里注释了runtime中相关的方法释义</p><p>后期遇到不认识的方法可在此查询其作用</p></blockquote><hr><h2 id="类相关操作函数"><a href="#类相关操作函数" class="headerlink" title="类相关操作函数"></a>类相关操作函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getName ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line">Class class_getSuperclass ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断给定的Class是否是一个元类</span></span><br><span class="line"><span class="built_in">BOOL</span> class_isMetaClass ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line">size_t class_getInstanceSize ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line">Ivar class_getInstanceVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line">Ivar class_getClassVariable ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成员变量</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取整个成员变量列表</span></span><br><span class="line">Ivar * class_copyIvarList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的属性</span></span><br><span class="line">objc_property_t class_getProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性列表</span></span><br><span class="line">objc_property_t * class_copyPropertyList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为类添加属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换类的属性</span></span><br><span class="line"><span class="keyword">void</span> class_replaceProperty ( Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line">Method class_getInstanceMethod ( Class cls, SEL name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line">Method class_getClassMethod ( Class cls, SEL name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line">Method * class_copyMethodList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替代方法的实现</span></span><br><span class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的具体实现</span></span><br><span class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</span><br><span class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="built_in">BOOL</span> class_respondsToSelector ( Class cls, SEL sel );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProtocol ( Class cls, Protocol *protocol );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol ( Class cls, Protocol *protocol );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line">Protocol * class_copyProtocolList ( Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取版本号</span></span><br><span class="line"><span class="keyword">int</span> class_getVersion ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="keyword">void</span> class_setVersion ( Class cls, <span class="keyword">int</span> version );</span><br></pre></td></tr></table></figure><h2 id="实例相关操作函数"><a href="#实例相关操作函数" class="headerlink" title="实例相关操作函数"></a>实例相关操作函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="keyword">id</span> object_copy ( <span class="keyword">id</span> obj, size_t size );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="keyword">id</span> object_dispose ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line">Ivar object_setInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line">Ivar object_getInstanceVariable ( <span class="keyword">id</span> obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **outValue );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="keyword">void</span> * object_getIndexedIvars ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回对象中实例变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar ( <span class="keyword">id</span> obj, Ivar ivar );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar ( <span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * object_getClassName ( <span class="keyword">id</span> obj );</span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line">Class object_getClass ( <span class="keyword">id</span> obj );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line">Class object_setClass ( <span class="keyword">id</span> obj, Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取已注册的类定义的列表</span></span><br><span class="line"><span class="keyword">int</span> objc_getClassList ( Class *buffer, <span class="keyword">int</span> bufferCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span><br><span class="line">Class * objc_copyClassList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的类定义</span></span><br><span class="line">Class objc_lookUpClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line">Class objc_getClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line">Class objc_getRequiredClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line">Class objc_getMetaClass ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取关联对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject ( <span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除关联对象</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects ( <span class="keyword">id</span> object );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有加载的Objective-C框架和动态库的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyImageNames ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * class_getImageName ( Class cls );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** objc_copyClassNamesForImage ( <span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure><h2 id="属性操作相关函数"><a href="#属性操作相关函数" class="headerlink" title="属性操作相关函数"></a>属性操作相关函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getName ( objc_property_t property );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * property_getAttributes ( objc_property_t property );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="keyword">char</span> * property_copyAttributeValue ( objc_property_t property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br></pre></td></tr></table></figure><h2 id="方法操作相关函数"><a href="#方法操作相关函数" class="headerlink" title="方法操作相关函数"></a>方法操作相关函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现</span></span><br><span class="line"><span class="keyword">id</span> method_invoke ( <span class="keyword">id</span> receiver, Method m, ... );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></span><br><span class="line"><span class="keyword">void</span> method_invoke_stret ( <span class="keyword">id</span> receiver, Method m, ... );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法名</span></span><br><span class="line">SEL method_getName ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line">IMP method_getImplementation ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * method_getTypeEncoding ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line"><span class="keyword">char</span> * method_copyReturnType ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line"><span class="keyword">char</span> * method_copyArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></span><br><span class="line"><span class="keyword">void</span> method_getReturnType ( Method m, <span class="keyword">char</span> *dst, size_t dst_len );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class="line"><span class="keyword">void</span> method_getArgumentType ( Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description * method_getDescription ( Method m );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line">IMP method_setImplementation ( Method m, IMP imp );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations ( Method m1, Method m2 );</span><br></pre></td></tr></table></figure><h2 id="选择器相关的操作函数"><a href="#选择器相关的操作函数" class="headerlink" title="选择器相关的操作函数"></a>选择器相关的操作函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * sel_getName ( SEL sel );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line">SEL sel_registerName ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Objective-C Runtime系统中注册一个方法</span></span><br><span class="line">SEL sel_getUid ( <span class="keyword">const</span> <span class="keyword">char</span> *str );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="built_in">BOOL</span> sel_isEqual ( SEL lhs, SEL rhs );</span><br></pre></td></tr></table></figure><h2 id="协议相关的操作函数"><a href="#协议相关的操作函数" class="headerlink" title="协议相关的操作函数"></a>协议相关的操作函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line">Protocol * objc_getProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line">Protocol ** objc_copyProtocolList ( <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line">Protocol * objc_allocateProtocol ( <span class="keyword">const</span> <span class="keyword">char</span> *name );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议</span></span><br><span class="line"><span class="keyword">void</span> objc_registerProtocol ( Protocol *proto );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="keyword">void</span> protocol_addMethodDescription ( Protocol *proto, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个已注册的协议到协议中</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProtocol ( Protocol *proto, Protocol *addition );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性</span></span><br><span class="line"><span class="keyword">void</span> protocol_addProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * protocol_getName ( Protocol *p );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_isEqual ( Protocol *proto, Protocol *other );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法的方法描述数组</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, <span class="built_in">BOOL</span> isRequiredMethod, <span class="built_in">BOOL</span> isInstanceMethod );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line">objc_property_t protocol_getProperty ( Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="built_in">BOOL</span> isRequiredProperty, <span class="built_in">BOOL</span> isInstanceProperty );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议采用的协议</span></span><br><span class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看协议是否采用了另一个协议</span></span><br><span class="line"><span class="built_in">BOOL</span> protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</span><br></pre></td></tr></table></figure><h2 id="block块相关的操作函数"><a href="#block块相关的操作函数" class="headerlink" title="block块相关的操作函数"></a>block块相关的操作函数</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line">IMP imp_implementationWithBlock ( <span class="keyword">id</span> block );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="keyword">id</span> imp_getBlock ( IMP anImp );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="built_in">BOOL</span> imp_removeBlock ( IMP anImp );</span><br></pre></td></tr></table></figure><h2 id="拦截调用函数"><a href="#拦截调用函数" class="headerlink" title="拦截调用函数"></a>拦截调用函数</h2><p>拦截调用就是在找不到调用的方法程序崩溃之前，有机会通过重写NSObject的四个方法来处理：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，可以加上自己的处理后返回YES</p></blockquote><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>和上一个方法类似，处理的是实例方法</p></blockquote><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要返回一个有这个方法的target</p></blockquote><hr><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation OBJC_SWIFT_UNAVAILABLE(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><blockquote><p>将你调用的不存在的方法打包成NSInvocation传给你。做完你自己的处理后，调用invokeWithTarget:方法让某个target触发这个方法</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这里注释了runtime中相关的方法释义&lt;/p&gt;
&lt;p&gt;后期遇到不认识的方法可在此查询其作用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类相关操作函数&quot;&gt;&lt;a href=&quot;#类相关操作函数&quot; class=&quot;header
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS runtime 总结（一）---- 基础成员</title>
    <link href="http://yoursite.com/2018/03/15/iOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89----%20%E5%9F%BA%E7%A1%80%E6%88%90%E5%91%98/"/>
    <id>http://yoursite.com/2018/03/15/iOS runtime 总结（一）---- 基础成员/</id>
    <published>2018-03-15T05:52:13.000Z</published>
    <updated>2018-03-16T07:25:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="runtime-简介"><a href="#runtime-简介" class="headerlink" title="runtime 简介"></a>runtime 简介</h2><p>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。比如：</p><p><code>[receiver message];</code></p><p>底层运行时会被编译器转化为：</p><p><code>objc_msgSend(receiver, selector)</code></p><p>如果其还有参数比如：</p><p><code>[receiver message:(id)arg...];</code></p><p>底层运行时会被编译器转化为：</p><p><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code></p><p>以上你可能看不出它的价值，但是我们需要了解的是 Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。</p><p>因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。</p><p>Runtime 基本是用 C 和汇编写的，由此可见苹果为了动态系统的高效而做出的努力。</p><p>在Objective-C代码中使用Runtime, 需要引入</p><p><code>#import &lt;objc/runtime.h&gt;</code></p><h2 id="runtime-作用及相关应用"><a href="#runtime-作用及相关应用" class="headerlink" title="runtime 作用及相关应用"></a>runtime 作用及相关应用</h2><h3 id="1-runtime作用"><a href="#1-runtime作用" class="headerlink" title="1. runtime作用"></a>1. runtime作用</h3><p>runtime是属于OC的底层, 可以进行一些非常底层的操作(用OC是无法现实的, 不好实现)。</p><ul><li>在程序运行过程中, 动态创建一个类(比如KVO的底层实现)</li><li>在程序运行过程中, 动态地为某个类添加属性\方法, 修改属性值\方法</li><li>遍历一个类的所有成员变量(属性)\所有方法</li></ul><h3 id="2-runtime相关应用"><a href="#2-runtime相关应用" class="headerlink" title="2. runtime相关应用"></a>2. runtime相关应用</h3><ul><li>NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)</li><li>字典 –&gt; 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)</li><li>KVO(利用runtime动态产生一个类)</li><li>用于封装框架(想怎么改就怎么改)</li></ul><h2 id="runtime-成员"><a href="#runtime-成员" class="headerlink" title="runtime 成员"></a>runtime 成员</h2><h3 id="1-Class-类"><a href="#1-Class-类" class="headerlink" title="1. Class - 类"></a>1. Class - 类</h3><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。objc_class结构体的定义如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY; <span class="comment">// 指向metaclass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line"></span><br><span class="line">    Class super_class                       OBJC2_UNAVAILABLE;  <span class="comment">// 指向父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name                        OBJC2_UNAVAILABLE;  <span class="comment">// 类名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> version                            OBJC2_UNAVAILABLE;  <span class="comment">// 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> info                               OBJC2_UNAVAILABLE;  <span class="comment">// 类信息，供运行期使用的一些位标识。如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> instance_size                      OBJC2_UNAVAILABLE;  <span class="comment">// 该类的实例变量大小(包括从父类继承下来的实例变量)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  <span class="comment">// 该类的成员变量链表，用于存储每个成员变量的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list **methodLists   OBJC2_UNAVAILABLE;  <span class="comment">// 方法定义的链表，如CLS_CLASS (0x1L),则存储实例方法，如CLS_META (0x2L)，则存储类方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_cache *cache                OBJC2_UNAVAILABLE;  <span class="comment">// 方法缓存，用于提升效率；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  <span class="comment">// 存储该类声明遵守的协议</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>对对象进行操作的方法一般以object_开头</p></li><li><p>对类进行操作的方法一般以class_开头</p></li><li><p>对类或对象的方法进行操作的方法一般以method_开头</p></li><li><p>对成员变量进行操作的方法一般以ivar_开头</p></li><li><p>对属性进行操作的方法一般以property_开头开头</p></li><li><p>对协议进行操作的方法一般以protocol_开头</p></li></ul></blockquote><h3 id="2-实例对象"><a href="#2-实例对象" class="headerlink" title="2. 实例对象"></a>2. 实例对象</h3><p>即objc_object表示的一个类的实例的结构体，它的定义如下</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><h3 id="3-元类-Meta-Class"><a href="#3-元类-Meta-Class" class="headerlink" title="3. 元类(Meta Class)"></a>3. 元类(Meta Class)</h3><p>meta-class是一个类对象的类。它存储着一个类的所有类方法。每个类都会有一个单独的meta-class。</p><h3 id="4-isa指针"><a href="#4-isa指针" class="headerlink" title="4. isa指针"></a>4. isa指针</h3><p>isa是一个指向结构体的指针：</p><ul><li><strong>实例对象</strong>中的isa指针指向对象所属类Class,这个Class中存储着成员变量和对象方法（“-”方法）</li><li><strong>Class</strong>中的isa指针指向元类，存储着static类型成员变量和类方法（“+”方法）。</li></ul><h3 id="5-方法调用过程"><a href="#5-方法调用过程" class="headerlink" title="5. 方法调用过程"></a>5. 方法调用过程</h3><ul><li><p><strong>调用对象的实例方法：</strong> </p><ul><li>先在自身isa指针指向的类（class）methodLists中查找该方法</li><li>如果找不到则会通过class的super_class指针找到父类的类对象结构体，然后从methodLists中查找该方法</li><li>如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根class</li><li>最后响应该方法，最后把该方法添加到cache列表中，以后再调用该方法，直接从cache中取出相应的方法调用</li><li>如果一直到根类还没有找到，转向拦截调用</li><li>如果没有重写拦截调用的方法，程序报错</li></ul></li><li><p><strong>调用类方法：</strong> </p><ul><li>先通过自己的isa指针找到metaclass，并从其中methodLists中查找该类方法</li><li>如果找不到则会通过metaclass的super_class指针找到父类的metaclass对象结构体，然后从methodLists中查找该方法</li><li>如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根metaclass</li><li>最后响应该方法，最后把该方法添加到cache列表中，以后再调用该方法，直接从cache中取出相应的方法调用</li><li>如果一直到根类还没有找到，转向拦截调用</li><li>如果没有重写拦截调用的方法，程序报错</li></ul></li></ul><h3 id="6-super"><a href="#6-super" class="headerlink" title="6.super"></a>6.super</h3><p>super与self不同，self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。<br>super的定义：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">     <span class="keyword">id</span> receiver;<span class="comment">//即消息的实际接收者</span></span><br><span class="line">     Class superClass;<span class="comment">//指针当前类的父类</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>例证：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self:%@ super:%@"</span>, <span class="keyword">self</span>, <span class="keyword">super</span>.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>打印结果：</p><p>2018-03-15 14:57:42.775938+0800 runtimeDemo1[4540:155849] self:&lt;ViewController: 0x7fb039d07160&gt; super:ViewController</p></blockquote><h3 id="7-SEL"><a href="#7-SEL" class="headerlink" title="7.SEL"></a>7.SEL</h3><p>SEL又叫选择器，是表示一个方法的selector的指针，本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。其定义如下：</p><p><code>typedef struct objc_selector *SEL;</code></p><h3 id="8-IMP"><a href="#8-IMP" class="headerlink" title="8.IMP"></a>8.IMP</h3><p>IMP实际上是一个函数指针，指向方法实现的首地址。SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。其定义如下：</p><p><code>id (*IMP)(id, SEL, ...)</code></p><h3 id="9-Method"><a href="#9-Method" class="headerlink" title="9. Method"></a>9. Method</h3><p>即objc_method表示的一个结构体，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息。它实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。Method用于表示类定义中的方法，定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line"></span><br><span class="line">    SEL method_name                 OBJC2_UNAVAILABLE;  <span class="comment">// 方法名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *method_types                  OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    IMP method_imp                      OBJC2_UNAVAILABLE;  <span class="comment">// 方法实现</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-Cache"><a href="#10-Cache" class="headerlink" title="10. Cache"></a>10. Cache</h3><p>Cache主要用来缓存。Cache其实就是一个存储Method的链表，主要是为了优化方法调用的性能。当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p><h3 id="11-Ivar"><a href="#11-Ivar" class="headerlink" title="11. Ivar"></a>11. Ivar</h3><p>Ivar表示类中的实例变量。Ivar其实就是一个指向objc_ivar结构体指针，它包含了变量名(ivar_name)、变量类型(ivar_type)等信息。</p><p>可以根据下面的这个例子，更好的理解class之间的关系：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog8pic/12.png" alt="picture12"></p><blockquote><p>注：关于“v@:”写法可参考<a href="http://www.it610.com/article/4089444.htm" target="_blank" rel="noopener">iOS学习之Objective-C 2.0 运行时系统编程-8类型编码</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;runtime-简介&quot;&gt;&lt;a href=&quot;#runtime-简介&quot; class=&quot;headerlink&quot; title=&quot;runtime 简介&quot;&gt;&lt;/a&gt;runtime 简介&lt;/h2&gt;&lt;p&gt;Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS 小技巧 ---- 方法总结</title>
    <link href="http://yoursite.com/2018/03/15/iOS%20%E5%B0%8F%E6%8A%80%E5%B7%A7%20----%20%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/15/iOS 小技巧 ---- 方法总结/</id>
    <published>2018-03-15T04:00:00.000Z</published>
    <updated>2018-03-19T08:36:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iOS中一些不常用方法总结："><a href="#iOS中一些不常用方法总结：" class="headerlink" title="iOS中一些不常用方法总结："></a>iOS中一些不常用方法总结：</h2><h3 id="1-删除navigationController中的某个VC"><a href="#1-删除navigationController中的某个VC" class="headerlink" title="1. 删除navigationController中的某个VC"></a>1. 删除navigationController中的某个VC</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *tempMarr = [<span class="built_in">NSMutableArray</span> arrayWithArray:<span class="keyword">self</span>.navigationController.viewControllers];</span><br><span class="line"><span class="keyword">if</span> (tempMarr.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    [tempMarr removeObjectAtIndex:tempMarr.count<span class="number">-2</span>];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.navigationController setViewControllers:tempMarr animated:<span class="literal">NO</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-将字符串中的字母转化为大写或小写"><a href="#2-将字符串中的字母转化为大写或小写" class="headerlink" title="2. 将字符串中的字母转化为大写或小写"></a>2. 将字符串中的字母转化为大写或小写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;123abcABC&quot;;</span><br><span class="line">str = [str uppercaseString]; //转化为大写</span><br><span class="line">str = [str lowercaseString]; //转化为小写</span><br></pre></td></tr></table></figure><h3 id="3-判断scrollView滑动方向"><a href="#3-判断scrollView滑动方向" class="headerlink" title="3. 判断scrollView滑动方向"></a>3. 判断scrollView滑动方向</h3><blockquote><p>这里以判断左右滑动为例，判断上下滑动则将对应的x替换为y即可</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IntroduceViewController</span> ()&lt;<span class="title">UIScrollViewDelegate</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> contentOffsetX;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> oldContentOffsetX;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> newContentOffsetX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始拖拽视图</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    </span><br><span class="line">    contentOffsetX = scrollView.contentOffset.x;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动时调用此方法(手指离开屏幕后)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    </span><br><span class="line">    newContentOffsetX = scrollView.contentOffset.x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newContentOffsetX &gt; oldContentOffsetX &amp;&amp; oldContentOffsetX &gt; contentOffsetX) &#123;  <span class="comment">// 向左滚动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (scrollView.contentOffset.x &gt; (_imageArray.count - <span class="number">1</span>) * SCREEN_WIDTH) &#123;</span><br><span class="line">            [<span class="keyword">self</span> gotoLoginVC];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newContentOffsetX &lt; oldContentOffsetX &amp;&amp; oldContentOffsetX &lt; contentOffsetX) &#123; <span class="comment">// 向右滚动</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (scrollView.dragging) &#123;  <span class="comment">// 拖拽</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((scrollView.contentOffset.x - contentOffsetX) &gt; <span class="number">5.0</span>f) &#123;  <span class="comment">// 向左拖拽</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (scrollView.contentOffset.x &gt; (_imageArray.count - <span class="number">1</span>) * SCREEN_WIDTH) &#123;</span><br><span class="line">                [<span class="keyword">self</span> gotoLoginVC];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((contentOffsetX - scrollView.contentOffset.x) &gt; <span class="number">5.0</span>f) &#123;   <span class="comment">// 向右拖拽</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成拖拽(滚动停止时调用此方法，手指离开屏幕前)</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="built_in">BOOL</span>)decelerate &#123;</span><br><span class="line">    </span><br><span class="line">    oldContentOffsetX = scrollView.contentOffset.x;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;iOS中一些不常用方法总结：&quot;&gt;&lt;a href=&quot;#iOS中一些不常用方法总结：&quot; class=&quot;headerlink&quot; title=&quot;iOS中一些不常用方法总结：&quot;&gt;&lt;/a&gt;iOS中一些不常用方法总结：&lt;/h2&gt;&lt;h3 id=&quot;1-删除navigationCon
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS多线程 ---- GCD使用总结</title>
    <link href="http://yoursite.com/2018/03/14/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%20----%20GCD%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/03/14/iOS多线程 ---- GCD使用总结/</id>
    <published>2018-03-14T01:21:34.000Z</published>
    <updated>2018-03-15T06:56:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、GCD简介"><a href="#一、GCD简介" class="headerlink" title="一、GCD简介"></a>一、GCD简介</h2><blockquote><p>Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。</p></blockquote><p><strong>使用GCD的好处</strong></p><ul><li>GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能</li><li>GCD 会自动利用更多的 CPU 内核（比如双核、四核）</li><li>GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）</li></ul><h2 id="二、GCD-常用术语"><a href="#二、GCD-常用术语" class="headerlink" title="二、GCD 常用术语"></a>二、GCD 常用术语</h2><p>在 GCD 中，我们通常在 block 里执行任务代码，执行任务有两种方式：<strong>同步执行（sync）</strong>和<strong>异步执行（async）</strong>。两者的主要区别是：<strong>是否等待队列的任务执行结束，以及是否具备开启新线程的能力。</strong></p><ul><li><strong>同步执行（sync）：</strong><ul><li>同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。</li><li>只能在当前线程中执行任务，不具备开启新线程的能力。</li></ul></li><li><strong>异步执行（async）：</strong><ul><li>异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。</li><li>可以在新的线程中执行任务，具备开启新线程的能力。</li></ul></li></ul><p>举个简单例子：你要打电话给小明和小白。</p><p>同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。</p><p>而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。</p><blockquote><p>注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。</p></blockquote><p><strong>队列（Dispatch Queue）：</strong> 这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/blog4pic/1.png" alt="picture1"></p><p>在 GCD 中有两种队列：<strong>串行队列</strong>和<strong>并发队列</strong>。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：<strong>执行顺序不同，以及开启线程数不同。</strong></p><ul><li><p>串行队列（Serial Dispatch Queue）：</p><ul><li>每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）</li></ul></li><li><p>并发队列（Concurrent Dispatch Queue）：</p><ul><li>可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）</li></ul></li></ul><h2 id="三、GCD提供的方法"><a href="#三、GCD提供的方法" class="headerlink" title="三、GCD提供的方法"></a>三、GCD提供的方法</h2><p>GCD 的使用步骤其实很简单，只有两步:</p><ol><li><p>创建一个队列（串行队列或并发队列）</p></li><li><p>将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）</p></li></ol><h3 id="1-队列的创建-获取方法"><a href="#1-队列的创建-获取方法" class="headerlink" title="1. 队列的创建/获取方法"></a>1. 队列的创建/获取方法</h3><ul><li>可以使用 <code>dispatch_queue_create</code> 来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。<code>DISPATCH_QUEUE_SERIAL</code> 表示串行队列，<code>DISPATCH_QUEUE_CONCURRENT</code> 表示并发队列。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行队列的创建方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// 并发队列的创建方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><ul><li>对于串行队列，GCD 提供了的一种特殊的串行队列：<strong>主队列（Main Dispatch Queue）</strong>。<ul><li>所有放在主队列中的任务，都会放到主线程中执行。</li><li>可使用 <code>dispatch_get_main_queue()</code> 获得主队列。</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主队列的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><ul><li><p>对于并发队列，GCD 默认提供了<strong>全局并发队列（Global Dispatch Queue）</strong>。</p><ul><li>可以使用 <code>dispatch_get_global_queue</code> 来获取。需要传入两个参数。第一个参数表示队列优先级，一般用 <code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code> 。第二个参数暂时没用，用 <code>0</code> 即可。</li></ul></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局并发队列的获取方法</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="2-任务的创建方法"><a href="#2-任务的创建方法" class="headerlink" title="2. 任务的创建方法"></a>2. 任务的创建方法</h3><p>GCD 提供了同步执行任务的创建方法 <code>dispatch_sync</code> 和异步执行任务创建方法 <code>dispatch_async</code> 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步执行任务创建方法</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放同步执行任务代码</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 异步执行任务创建方法</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 这里放异步执行任务代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：</p><blockquote><ol><li>同步执行 + 并发队列</li><li>异步执行 + 并发队列</li><li>同步执行 + 串行队列</li><li>异步执行 + 串行队列</li></ol></blockquote><p>实际上，刚才还说了两种特殊队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。</p><blockquote><ol><li>同步执行 + 主队列</li><li>异步执行 + 主队列</li></ol></blockquote><h2 id="四、GCD的基本使用"><a href="#四、GCD的基本使用" class="headerlink" title="四、GCD的基本使用"></a>四、GCD的基本使用</h2><h3 id="1-同步执行-并发队列"><a href="#1-同步执行-并发队列" class="headerlink" title="1. 同步执行 + 并发队列"></a>1. 同步执行 + 并发队列</h3><ul><li>在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 10:48:58.322012+0800 GCDDemo1[1849:70838] currentThread—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}<br>2018-03-14 10:48:58.322214+0800 GCDDemo1[1849:70838] syncConcurrent—begin<br>2018-03-14 10:49:00.322971+0800 GCDDemo1[1849:70838] 1—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}<br>2018-03-14 10:49:02.323947+0800 GCDDemo1[1849:70838] 1—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}<br>2018-03-14 10:49:04.324712+0800 GCDDemo1[1849:70838] 2—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}<br>2018-03-14 10:49:06.325088+0800 GCDDemo1[1849:70838] 2—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}<br>2018-03-14 10:49:08.325530+0800 GCDDemo1[1849:70838] 3—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}<br>2018-03-14 10:49:10.326147+0800 GCDDemo1[1849:70838] 3—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}<br>2018-03-14 10:49:10.326585+0800 GCDDemo1[1849:70838] syncConcurrent—end</p></blockquote><p>从 <code>同步执行 + 并发队列</code> 中可看到：</p><ul><li><p>所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（同步执行不具备开启新线程的能力）。</p></li><li><p>所有任务都在打印的 <code>syncConcurrent---begin</code> 和 <code>syncConcurrent---end</code> 之间执行的（同步任务需要等待队列的任务执行结束）。</p></li><li>任务按顺序执行的。按顺序执行的原因：虽然 <code>并发队列</code> 可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（<code>同步任务</code>不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（<code>同步任务</code>需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。</li></ul><h3 id="2-异步执行-并发队列"><a href="#2-异步执行-并发队列" class="headerlink" title="2. 异步执行 + 并发队列"></a>2. 异步执行 + 并发队列</h3><ul><li>可以开启多个线程，任务交替（同时）执行。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 并发队列</span></span><br><span class="line"><span class="comment"> * 特点：可以开启多个线程，任务交替（同时）执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncConcurrent &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncConcurrent---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 11:01:57.692961+0800 GCDDemo1[1905:78877] currentThread—&lt;NSThread: 0x60000006ccc0&gt;{number = 1, name = main}<br>2018-03-14 11:01:57.719769+0800 GCDDemo1[1905:78877] asyncConcurrent—begin<br>2018-03-14 11:01:57.719990+0800 GCDDemo1[1905:78877] asyncConcurrent—end<br>2018-03-14 11:01:59.721258+0800 GCDDemo1[1905:79082] 1—&lt;NSThread: 0x600000263040&gt;{number = 3, name = (null)}<br>2018-03-14 11:01:59.721264+0800 GCDDemo1[1905:79081] 2—&lt;NSThread: 0x60000026b900&gt;{number = 4, name = (null)}<br>2018-03-14 11:01:59.721296+0800 GCDDemo1[1905:79085] 3—&lt;NSThread: 0x604000278180&gt;{number = 5, name = (null)}<br>2018-03-14 11:02:01.722360+0800 GCDDemo1[1905:79081] 2—&lt;NSThread: 0x60000026b900&gt;{number = 4, name = (null)}<br>2018-03-14 11:02:01.722360+0800 GCDDemo1[1905:79082] 1—&lt;NSThread: 0x600000263040&gt;{number = 3, name = (null)}<br>2018-03-14 11:02:01.722382+0800 GCDDemo1[1905:79085] 3—&lt;NSThread: 0x604000278180&gt;{number = 5, name = (null)}</p></blockquote><p>在 <code>异步执行 + 并发队列</code> 中可以看出：</p><ul><li>除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（<code>异步执行</code>具备开启新线程的能力。且<code>并发队列</code>可开启多个线程，同时执行多个任务）。</li><li>所有任务是在打印的 <code>syncConcurrent---begin</code> 和 <code>syncConcurrent---end</code> 之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（<code>异步执行</code>不做等待，可以继续执行任务）。</li></ul><h3 id="3-同步执行-串行队列"><a href="#3-同步执行-串行队列" class="headerlink" title="3. 同步执行 + 串行队列"></a>3. 同步执行 + 串行队列</h3><ul><li>不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为：</p><p>2018-03-14 11:06:49.184007+0800 GCDDemo1[1945:82494] currentThread—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}<br>2018-03-14 11:06:49.184219+0800 GCDDemo1[1945:82494] syncSerial—begin<br>2018-03-14 11:06:51.185431+0800 GCDDemo1[1945:82494] 1—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}<br>2018-03-14 11:06:53.186840+0800 GCDDemo1[1945:82494] 1—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}<br>2018-03-14 11:06:55.187418+0800 GCDDemo1[1945:82494] 2—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}<br>2018-03-14 11:06:57.188837+0800 GCDDemo1[1945:82494] 2—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}<br>2018-03-14 11:06:59.189861+0800 GCDDemo1[1945:82494] 3—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}<br>2018-03-14 11:07:01.190613+0800 GCDDemo1[1945:82494] 3—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}<br>2018-03-14 11:07:01.191055+0800 GCDDemo1[1945:82494] syncSerial—end</p></blockquote><p>在<code>同步执行 + 串行队列</code>可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行不具备开启新线程的能力）。</li><li>所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><h3 id="4-异步执行-串行队列"><a href="#4-异步执行-串行队列" class="headerlink" title="4. 异步执行 + 串行队列"></a>4. 异步执行 + 串行队列</h3><ul><li>会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 串行队列</span></span><br><span class="line"><span class="comment"> * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncSerial &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncSerial---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为：</p><p>2018-03-14 11:10:25.852255+0800 GCDDemo1[1987:85325] currentThread—&lt;NSThread: 0x60400007c0c0&gt;{number = 1, name = main}<br>2018-03-14 11:10:25.852446+0800 GCDDemo1[1987:85325] asyncSerial—begin<br>2018-03-14 11:10:25.852601+0800 GCDDemo1[1987:85325] asyncSerial—end<br>2018-03-14 11:10:27.854119+0800 GCDDemo1[1987:85430] 1—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}<br>2018-03-14 11:10:29.856678+0800 GCDDemo1[1987:85430] 1—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}<br>2018-03-14 11:10:31.860508+0800 GCDDemo1[1987:85430] 2—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}<br>2018-03-14 11:10:33.863252+0800 GCDDemo1[1987:85430] 2—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}<br>2018-03-14 11:10:35.863730+0800 GCDDemo1[1987:85430] 3—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}<br>2018-03-14 11:10:37.865454+0800 GCDDemo1[1987:85430] 3—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}</p></blockquote><p>在<code>异步执行 + 串行队列</code>可以看到：</p><ul><li>开启了一条新线程（异步执行具备开启新线程的能力，<code>串行队列</code>只开启一个线程）。</li><li>所有任务是在打印的 <code>syncConcurrent---begin</code> 和 <code>syncConcurrent---end</code> 之后才开始执行的（<code>异步执行</code>不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（<code>串行队列</code>每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><hr><p><strong>主队列：</strong>GCD自带的一种特殊的串行队列</p><pre><code>- 所有放在主队列中的任务，都会放到主线程中执行- 可使用dispatch_get_main_queue()获得主队列</code></pre><h3 id="5-同步执行-主队列"><a href="#5-同步执行-主队列" class="headerlink" title="5. 同步执行 + 主队列"></a>5. 同步执行 + 主队列</h3><p><code>同步执行 + 主队列</code> 在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。</p><h4 id="5-1-在主线程中调用同步执行-主队列"><a href="#5-1-在主线程中调用同步执行-主队列" class="headerlink" title="5.1 在主线程中调用同步执行 + 主队列"></a>5.1 在主线程中调用<code>同步执行 + 主队列</code></h4><ul><li>互相等待卡住不可行</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点(主线程调用)：互等卡主不执行。</span></span><br><span class="line"><span class="comment"> * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)syncMain &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"syncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果</p><p>2018-03-14 11:17:39.275258+0800 GCDDemo1[2046:90602] currentThread—&lt;NSThread: 0x60400006e740&gt;{number = 1, name = main}<br>2018-03-14 11:17:39.275437+0800 GCDDemo1[2046:90602] syncMain—begin</p></blockquote><p>在<code>同步执行 + 主队列</code>可以惊奇的发现：</p><ul><li>在主线程中使用<code>同步执行 + 主队列</code>，追加到主线程的任务1、任务2、任务3都不再执行了，而且syncMain—end也没有打印，在Xcode 9上还会报崩溃。这是为什么呢？</li></ul><p>这是因为我们在主线程中执行 <code>syncMain</code> 方法，相当于把 <code>syncMain</code> 任务放到了主线程的队列中。而 <code>同步执行</code> 会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把 <code>任务1</code> 追加到主队列中，<code>任务1</code> 就在等待主线程处理完 <code>syncMain</code> 任务。而 <code>syncMain</code> 任务需要等待 <code>任务1</code> 执行完毕，才能接着执行。</p><p>那么，现在的情况就是 <code>syncMain</code> 任务和 <code>任务1</code> 都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且 <code>syncMain---end</code> 也没有打印。</p><h4 id="5-2-在其他线程中调用同步执行-主队列"><a href="#5-2-在其他线程中调用同步执行-主队列" class="headerlink" title="5.2 在其他线程中调用同步执行 + 主队列"></a>5.2 在其他线程中调用<code>同步执行 + 主队列</code></h4><ul><li>不会开启新线程，执行完一个任务，再执行下一个任务</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行</span></span><br><span class="line"> selector 任务</span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(syncMain) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 11:23:05.466225+0800 GCDDemo1[2080:94606] currentThread—&lt;NSThread: 0x604000270f40&gt;{number = 3, name = (null)}<br>2018-03-14 11:23:05.478127+0800 GCDDemo1[2080:94606] syncMain—begin<br>2018-03-14 11:23:07.480904+0800 GCDDemo1[2080:94470] 1—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}<br>2018-03-14 11:23:09.481443+0800 GCDDemo1[2080:94470] 1—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}<br>2018-03-14 11:23:11.484207+0800 GCDDemo1[2080:94470] 2—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}<br>2018-03-14 11:23:13.486038+0800 GCDDemo1[2080:94470] 2—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}<br>2018-03-14 11:23:15.488007+0800 GCDDemo1[2080:94470] 3—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}<br>2018-03-14 11:23:17.488561+0800 GCDDemo1[2080:94470] 3—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}<br>2018-03-14 11:23:17.490313+0800 GCDDemo1[2080:94606] syncMain—end</p></blockquote><p>在其他线程中使用<code>同步执行 + 主队列</code>可看到：</p><ul><li>所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在<code>主队列</code>中的任务，都会放到主线程中执行）。</li><li>所有任务都在打印的 <code>syncConcurrent---begin</code> 和 <code>syncConcurrent---end</code> 之间执行（<code>同步任务</code>需要等待队列的任务执行结束）。</li><li>任务是按顺序执行的（主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><p>为什么现在就不会卡住了呢？<br>因为 <code>syncMain 任务</code> 放到了其他线程里，而 <code>任务1、任务2、任务3</code> 都在追加到主队列中，这三个任务都会在主线程中执行。 <code>syncMain 任务</code> 在其他线程中执行到追加 <code>任务1</code> 到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的 <code>任务1</code> ，等 <code>任务1</code> 执行完毕，再接着执行 <code>任务2、任务3</code> 。所以这里不会卡住线程。</p><h3 id="6-异步执行-主队列"><a href="#6-异步执行-主队列" class="headerlink" title="6. 异步执行 + 主队列"></a>6. 异步执行 + 主队列</h3><ul><li>只在主线程中执行任务，执行完一个任务，再执行下一个任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步执行 + 主队列</span></span><br><span class="line"><span class="comment"> * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)asyncMain &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 11:29:40.481045+0800 GCDDemo1[2108:98613] currentThread—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}<br>2018-03-14 11:29:40.481543+0800 GCDDemo1[2108:98613] asyncMain—begin<br>2018-03-14 11:29:40.481784+0800 GCDDemo1[2108:98613] asyncMain—end<br>2018-03-14 11:29:42.489512+0800 GCDDemo1[2108:98613] 1—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}<br>2018-03-14 11:29:44.489838+0800 GCDDemo1[2108:98613] 1—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}<br>2018-03-14 11:29:46.490323+0800 GCDDemo1[2108:98613] 2—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}<br>2018-03-14 11:29:48.491654+0800 GCDDemo1[2108:98613] 2—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}<br>2018-03-14 11:29:50.492748+0800 GCDDemo1[2108:98613] 3—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}<br>2018-03-14 11:29:52.494553+0800 GCDDemo1[2108:98613] 3—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}</p></blockquote><p>在<code>异步执行 + 主队列</code>可以看到：</p><ul><li>所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然<code>异步执行</code>具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。</li><li>所有任务是在打印的 <code>syncConcurrent—begin</code> 和 <code>syncConcurrent—end</code> 之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。</li><li>任务是按顺序执行的（因为主队列是<code>串行队列</code>，每次只有一个任务被执行，任务一个接一个按顺序执行）。</li></ul><h2 id="五、GCD-线程间的通信"><a href="#五、GCD-线程间的通信" class="headerlink" title="五、GCD 线程间的通信"></a>五、GCD 线程间的通信</h2><p>在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)communication &#123;</span><br><span class="line">    <span class="comment">// 获取全局并发队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>); </span><br><span class="line">    <span class="comment">// 获取主队列</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue(); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 异步追加任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            <span class="comment">// 追加在主线程中执行的任务</span></span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 13:50:07.799131+0800 GCDDemo1[2571:160671] 1—&lt;NSThread: 0x604000079900&gt;{number = 3, name = (null)}<br>2018-03-14 13:50:09.800005+0800 GCDDemo1[2571:160671] 1—&lt;NSThread: 0x604000079900&gt;{number = 3, name = (null)}<br>2018-03-14 13:50:11.801108+0800 GCDDemo1[2571:160469] 2—&lt;NSThread: 0x6000000660c0&gt;{number = 1, name = main}</p></blockquote><ul><li>可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。</li></ul><h2 id="六、GCD-的其他方法"><a href="#六、GCD-的其他方法" class="headerlink" title="六、GCD 的其他方法"></a>六、GCD 的其他方法</h2><h3 id="1-GCD-栅栏方法：dispatch-barrier-async"><a href="#1-GCD-栅栏方法：dispatch-barrier-async" class="headerlink" title="1. GCD 栅栏方法：dispatch_barrier_async"></a>1. GCD 栅栏方法：dispatch_barrier_async</h3><ul><li>我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到 <code>dispatch_barrier_async</code> 方法在两个操作组间形成栅栏。</li><li><code>dispatch_barrier_async</code> 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 <code>dispatch_barrier_async</code> 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栅栏方法 dispatch_barrier_async</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)barrier &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"net.bujige.testQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务 barrier</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"barrier---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);<span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务4</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"4---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 14:08:13.366011+0800 GCDDemo1[2727:170441] 2—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)}<br>2018-03-14 14:08:13.366011+0800 GCDDemo1[2727:170442] 1—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}<br>2018-03-14 14:08:15.370119+0800 GCDDemo1[2727:170441] 2—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)}<br>2018-03-14 14:08:15.370119+0800 GCDDemo1[2727:170442] 1—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}<br>2018-03-14 14:08:17.374574+0800 GCDDemo1[2727:170442] barrier—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}<br>2018-03-14 14:08:19.375400+0800 GCDDemo1[2727:170442] barrier—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}<br>2018-03-14 14:08:21.376229+0800 GCDDemo1[2727:170441] 4—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)}<br>2018-03-14 14:08:21.376229+0800 GCDDemo1[2727:170442] 3—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}<br>2018-03-14 14:08:23.377080+0800 GCDDemo1[2727:170442] 3—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}<br>2018-03-14 14:08:23.377080+0800 GCDDemo1[2727:170441] 4—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)}</p></blockquote><p>在 <code>dispatch_barrier_async</code> 执行结果中可以看出：</p><ul><li>在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。</li></ul><h3 id="2-GCD-延时执行方法：dispatch-after"><a href="#2-GCD-延时执行方法：dispatch-after" class="headerlink" title="2. GCD 延时执行方法：dispatch_after"></a>2. GCD 延时执行方法：dispatch_after</h3><p>我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的 <code>dispatch_after</code> 函数来实现。<br>需要注意的是：<code>dispatch_after</code> 函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code> 函数是很有效的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时执行方法 dispatch_after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)after &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"asyncMain---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 2.0秒后异步追加任务代码到主队列，并开始执行</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"after---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">&gt; 输出结果：</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">2018</span><span class="number">-03</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">45.078709</span>+<span class="number">0800</span> GCDDemo1[<span class="number">2783</span>:<span class="number">173596</span>] currentThread---&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006c840</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">45.078902</span>+<span class="number">0800</span> GCDDemo1[<span class="number">2783</span>:<span class="number">173596</span>] asyncMain---begin</span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-14</span> <span class="number">14</span>:<span class="number">12</span>:<span class="number">47.261070</span>+<span class="number">0800</span> GCDDemo1[<span class="number">2783</span>:<span class="number">173596</span>] after---&lt;<span class="built_in">NSThread</span>: <span class="number">0x60400006c840</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"></span><br><span class="line">可以看出：在打印 `asyncMain---begin` 之后大约 <span class="number">2.0</span> 秒的时间，打印了 `after---&lt;<span class="built_in">NSThread</span>: <span class="number">0x60000006ee00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;`</span><br><span class="line"></span><br><span class="line"><span class="meta">### 3. GCD 一次性代码（只执行一次）：dispatch_once</span></span><br><span class="line"></span><br><span class="line">- 我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 `<span class="built_in">dispatch_once</span>` 函数。使用</span><br><span class="line">`<span class="built_in">dispatch_once</span>` 函数能保证某段代码在程序运行过程中只被执行<span class="number">1</span>次，并且即使在多线程的环境下，`<span class="built_in">dispatch_once</span>` 也可以保证线程安全。</span><br><span class="line"></span><br><span class="line">``` objectivec</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一次性代码（只执行一次）dispatch_once</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)once &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 只执行1次的代码(这里面默认是线程安全的)</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-GCD-快速迭代方法：dispatch-apply"><a href="#4-GCD-快速迭代方法：dispatch-apply" class="headerlink" title="4. GCD 快速迭代方法：dispatch_apply"></a>4. GCD 快速迭代方法：dispatch_apply</h3><ul><li>通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数 dispatch_apply。dispatch_apply 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。</li></ul><p>如果是在串行队列中使用 <code>dispatch_apply</code>，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。<br>我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。<code>dispatch_apply</code> 可以 在多个线程中同时（异步）遍历多个数字。<br>还有一点，无论是在串行队列，还是异步队列中，<code>dispatch_apply</code> 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 <code>dispatch_group_wait</code>方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速迭代方法 dispatch_apply</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)apply &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"apply---begin"</span>);</span><br><span class="line">    dispatch_apply(<span class="number">6</span>, queue, ^(size_t index) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%zd---%@"</span>,index, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"apply---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 14:24:35.502250+0800 GCDDemo1[2885:180445] apply—begin<br>2018-03-14 14:24:35.503352+0800 GCDDemo1[2885:180445] 0—&lt;NSThread: 0x6000000726c0&gt;{number = 1, name = main}<br>2018-03-14 14:24:35.503375+0800 GCDDemo1[2885:180520] 3—&lt;NSThread: 0x60000026f980&gt;{number = 5, name = (null)}<br>2018-03-14 14:24:35.503353+0800 GCDDemo1[2885:180524] 1—&lt;NSThread: 0x60000026fb00&gt;{number = 3, name = (null)}<br>2018-03-14 14:24:35.503394+0800 GCDDemo1[2885:180523] 2—&lt;NSThread: 0x60000026fc00&gt;{number = 4, name = (null)}<br>2018-03-14 14:24:35.503600+0800 GCDDemo1[2885:180524] 4—&lt;NSThread: 0x60000026fb00&gt;{number = 3, name = (null)}<br>2018-03-14 14:24:35.503606+0800 GCDDemo1[2885:180520] 5—&lt;NSThread: 0x60000026f980&gt;{number = 5, name = (null)}<br>2018-03-14 14:24:35.503725+0800 GCDDemo1[2885:180445] apply—end</p></blockquote><p>因为是在并发队列中异步队执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是 <code>apply---end一</code> 定在最后执行。这是因为 <code>dispatch_apply</code> 函数会等待全部任务执行完毕。</p><h3 id="5-GCD-的队列组：dispatch-group"><a href="#5-GCD-的队列组：dispatch-group" class="headerlink" title="5. GCD 的队列组：dispatch_group"></a>5. GCD 的队列组：dispatch_group</h3><p>有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。</p><ul><li>调用队列组的 <code>dispatch_group_async</code> 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 <code>dispatch_group_enter</code>、<code>dispatch_group_leave</code> 组合 来实现 <code>dispatch_group_async</code>。</li><li>调用队列组的 <code>dispatch_group_notify</code> 回到指定线程执行任务。或者使用 <code>dispatch_group_wait</code> 回到当前线程继续向下执行（会阻塞当前线程）。</li></ul><h4 id="5-1-dispatch-group-notify"><a href="#5-1-dispatch-group-notify" class="headerlink" title="5.1 dispatch_group_notify"></a>5.1 dispatch_group_notify</h4><ul><li>监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列组 dispatch_group_notify</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)groupNotify &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"group---end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 15:14:56.708549+0800 GCDDemo1[3363:210384] currentThread—&lt;NSThread: 0x600000262600&gt;{number = 1, name = main}<br>2018-03-14 15:14:56.708977+0800 GCDDemo1[3363:210384] group—begin<br>2018-03-14 15:14:58.713556+0800 GCDDemo1[3363:210541] 2—&lt;NSThread: 0x604000460ec0&gt;{number = 4, name = (null)}<br>2018-03-14 15:14:58.713556+0800 GCDDemo1[3363:210543] 1—&lt;NSThread: 0x604000461740&gt;{number = 3, name = (null)}<br>2018-03-14 15:15:00.718094+0800 GCDDemo1[3363:210541] 2—&lt;NSThread: 0x604000460ec0&gt;{number = 4, name = (null)}<br>2018-03-14 15:15:00.718094+0800 GCDDemo1[3363:210543] 1—&lt;NSThread: 0x604000461740&gt;{number = 3, name = (null)}<br>2018-03-14 15:15:02.719004+0800 GCDDemo1[3363:210384] 3—&lt;NSThread: 0x600000262600&gt;{number = 1, name = main}<br>2018-03-14 15:15:04.720260+0800 GCDDemo1[3363:210384] 3—&lt;NSThread: 0x600000262600&gt;{number = 1, name = main}<br>2018-03-14 15:15:04.720453+0800 GCDDemo1[3363:210384] group—end</p></blockquote><p>从 <code>dispatch_group_notify</code> 相关代码运行输出结果可以看出：<br>当所有任务都执行完成之后，才执行 <code>dispatch_group_notify</code> block 中的任务。</p><h4 id="5-2-dispatch-group-wait"><a href="#5-2-dispatch-group-wait" class="headerlink" title="5.2 dispatch_group_wait"></a>5.2 dispatch_group_wait</h4><ul><li>暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列组 dispatch_group_wait</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)groupWait &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）</span></span><br><span class="line">    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group---end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 15:19:06.067937+0800 GCDDemo1[3413:213407] currentThread—&lt;NSThread: 0x600000262000&gt;{number = 1, name = main}<br>2018-03-14 15:19:06.068098+0800 GCDDemo1[3413:213407] group—begin<br>2018-03-14 15:19:08.072494+0800 GCDDemo1[3413:213491] 1—&lt;NSThread: 0x600000471640&gt;{number = 3, name = (null)}<br>2018-03-14 15:19:08.072494+0800 GCDDemo1[3413:213490] 2—&lt;NSThread: 0x60400027b2c0&gt;{number = 4, name = (null)}<br>2018-03-14 15:19:10.077314+0800 GCDDemo1[3413:213490] 2—&lt;NSThread: 0x60400027b2c0&gt;{number = 4, name = (null)}<br>2018-03-14 15:19:10.077314+0800 GCDDemo1[3413:213491] 1—&lt;NSThread: 0x600000471640&gt;{number = 3, name = (null)}<br>2018-03-14 15:19:10.077544+0800 GCDDemo1[3413:213407] group—end</p></blockquote><p>从 <code>dispatch_group_wait</code> 相关代码运行输出结果可以看出：<br>当所有任务执行完成之后，才执行 <code>dispatch_group_wait</code> 之后的操作。但是，使用 <code>dispatch_group_wait</code> 会阻塞当前线程。</p><h4 id="5-3-dispatch-group-enter、dispatch-group-leave"><a href="#5-3-dispatch-group-enter、dispatch-group-leave" class="headerlink" title="5.3 dispatch_group_enter、dispatch_group_leave"></a>5.3 dispatch_group_enter、dispatch_group_leave</h4><ul><li><code>dispatch_group_enter</code> 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1</li><li><code>dispatch_group_leave</code> 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。</li><li>当 group 中未执行完毕任务数为0的时候，才会使 <code>dispatch_group_wait</code> 解除阻塞，以及执行追加到 <code>dispatch_group_notify</code> 中的任务。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列组 dispatch_group_enter、dispatch_group_leave</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)groupEnterAndLeave</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"group---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_enter(group);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"group---end"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）</span></span><br><span class="line"><span class="comment">//    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    NSLog(@"group---end");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 15:36:54.609837+0800 GCDDemo1[3574:223779] currentThread—&lt;NSThread: 0x600000073880&gt;{number = 1, name = main}<br>2018-03-14 15:36:54.610131+0800 GCDDemo1[3574:223779] group—begin<br>2018-03-14 15:36:56.615708+0800 GCDDemo1[3574:223890] 2—&lt;NSThread: 0x6040004611c0&gt;{number = 3, name = (null)}<br>2018-03-14 15:36:56.615711+0800 GCDDemo1[3574:223894] 1—&lt;NSThread: 0x600000269a80&gt;{number = 4, name = (null)}<br>2018-03-14 15:36:58.620700+0800 GCDDemo1[3574:223890] 2—&lt;NSThread: 0x6040004611c0&gt;{number = 3, name = (null)}<br>2018-03-14 15:36:58.620703+0800 GCDDemo1[3574:223894] 1—&lt;NSThread: 0x600000269a80&gt;{number = 4, name = (null)}<br>2018-03-14 15:37:00.621517+0800 GCDDemo1[3574:223779] 3—&lt;NSThread: 0x600000073880&gt;{number = 1, name = main}<br>2018-03-14 15:37:02.621943+0800 GCDDemo1[3574:223779] 3—&lt;NSThread: 0x600000073880&gt;{number = 1, name = main}<br>2018-03-14 15:37:02.622138+0800 GCDDemo1[3574:223779] group—end</p></blockquote><p>从 <code>dispatch_group_enter、dispatch_group_leave</code> 相关代码运行结果中可以看出：当所有任务执行完成之后，才执行  <code>dispatch_group_notify</code> 中的任务。这里的 <code>dispatch_group_enter、dispatch_group_leave</code> 组合，其实等同于 <code>dispatch_group_async</code>。</p><h3 id="6-GCD-信号量：dispatch-semaphore"><a href="#6-GCD-信号量：dispatch-semaphore" class="headerlink" title="6. GCD 信号量：dispatch_semaphore"></a>6. GCD 信号量：dispatch_semaphore</h3><p>GCD 中的信号量是指 <strong>Dispatch Semaphore</strong>，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 <strong>Dispatch Semaphore</strong> 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。</p><p><strong>Dispatch Semaphore</strong> 提供了三个函数：</p><ul><li><code>dispatch_semaphore_create</code>: 创建一个Semaphore并初始化信号的总量</li><li><code>dispatch_semaphore_signal</code>: 发送一个信号，让信号总量加1</li><li><code>dispatch_semaphore_wait</code>: 可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</li></ul><blockquote><p>注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。</p></blockquote><p>Dispatch Semaphore 在实际开发中主要用于：</p><ul><li>保持线程同步，将异步执行任务转换为同步执行任务</li><li>保证线程安全，为线程加锁</li></ul><h4 id="6-1-Dispatch-Semaphore-线程同步"><a href="#6-1-Dispatch-Semaphore-线程同步" class="headerlink" title="6.1 Dispatch Semaphore 线程同步"></a>6.1 Dispatch Semaphore 线程同步</h4><p>我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)tasksForKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    __block <span class="built_in">NSArray</span> *tasks = <span class="literal">nil</span>;</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(dataTasks))]) &#123;</span><br><span class="line">            tasks = dataTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(uploadTasks))]) &#123;</span><br><span class="line">            tasks = uploadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(downloadTasks))]) &#123;</span><br><span class="line">            tasks = downloadTasks;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(tasks))]) &#123;</span><br><span class="line">            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:<span class="string">@"@unionOfArrays.self"</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * semaphore 线程同步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)semaphoreSync &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"semaphore---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    __block <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 追加任务1</span></span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];              <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        </span><br><span class="line">        number = <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"semaphore---end,number = %zd"</span>,number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：</p><p>2018-03-14 16:02:54.230308+0800 GCDDemo1[3783:239611] currentThread—&lt;NSThread: 0x604000066500&gt;{number = 1, name = main}<br>2018-03-14 16:02:54.230478+0800 GCDDemo1[3783:239611] semaphore—begin<br>2018-03-14 16:02:56.235662+0800 GCDDemo1[3783:239848] 1—&lt;NSThread: 0x604000270980&gt;{number = 3, name = (null)}<br>2018-03-14 16:02:56.236054+0800 GCDDemo1[3783:239611] semaphore—end,number = 100</p></blockquote><p>从 Dispatch Semaphore 实现线程同步的代码可以看到：</p><ul><li><code>semaphore---end</code> 是在执行完 <code>number = 100</code>; 之后才打印的。而且输出结果 number 为 100。<br>这是因为<code>异步执行</code>不会做任何等待，可以继续执行任务。<code>异步执行</code>将任务1追加到队列之后，不做等待，接着执行<code>dispatch_semaphore_wait方法</code>。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到<code>dispatch_semaphore_signal</code>之后，总信号量，此时 semaphore == 1，<code>dispatch_semaphore_wait</code>方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印<code>semaphore---end,number = 100</code>。这样就实现了线程同步，将异步执行任务转换为同步执行任务。</li></ul><h4 id="6-2-Dispatch-Semaphore-线程安全和线程同步（为线程加锁）"><a href="#6-2-Dispatch-Semaphore-线程安全和线程同步（为线程加锁）" class="headerlink" title="6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）"></a>6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）</h4><p><strong>线程安全</strong>：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。</p><p><strong>线程同步</strong>：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。</p><p>举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。</p><p>下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。</p><p>场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。</p><h4 id="6-2-1-非线程安全（不使用-semaphore）"><a href="#6-2-1-非线程安全（不使用-semaphore）" class="headerlink" title="6.2.1 非线程安全（不使用 semaphore）"></a>6.2.1 非线程安全（不使用 semaphore）</h4><p>先来看看不考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非线程安全：不使用 semaphore</span></span><br><span class="line"><span class="comment"> * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusNotSave &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"semaphore---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// queue1 代表北京火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"net.bujige.testQueue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="comment">// queue2 代表上海火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"net.bujige.testQueue2"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        [weakSelf saleTicketNotSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售卖火车票(非线程安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketNotSafe &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;  <span class="comment">//如果还有票，继续售卖</span></span><br><span class="line">            <span class="keyword">self</span>.ticketSurplusCount--;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%d 窗口：%@"</span>, <span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread]]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果已卖完，关闭售票窗口</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果（部分）：</p><p>2018-03-14 16:13:29.568246+0800 GCDDemo1[3911:246879] currentThread—&lt;NSThread: 0x60400007f480&gt;{number = 1, name = main}<br>2018-03-14 16:13:29.568413+0800 GCDDemo1[3911:246879] semaphore—begin<br>2018-03-14 16:13:29.568747+0800 GCDDemo1[3911:246935] 剩余票数：48 窗口：&lt;NSThread: 0x600000477100&gt;{number = 3, name = (null)}<br>2018-03-14 16:13:29.568802+0800 GCDDemo1[3911:246938] 剩余票数：49 窗口：&lt;NSThread: 0x60400026f880&gt;{number = 4, name = (null)}<br>2018-03-14 16:13:29.770884+0800 GCDDemo1[3911:246938] 剩余票数：47 窗口：&lt;NSThread: 0x60400026f880&gt;{number = 4, name = (null)}<br>2018-03-14 16:13:29.770884+0800 GCDDemo1[3911:246935] 剩余票数：46 窗口：&lt;NSThread: 0x600000477100&gt;{number = 3, name = (null)}<br>2018-03-14 16:13:29.975337+0800 GCDDemo1[3911:246938] 剩余票数：44 窗口：&lt;NSThread: 0x60400026f880&gt;{number = 4, name = (null)}</p><p>…</p></blockquote><p>可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。</p><h4 id="6-2-2-线程安全（使用-semaphore-加锁）"><a href="#6-2-2-线程安全（使用-semaphore-加锁）" class="headerlink" title="6.2.2 线程安全（使用 semaphore 加锁）"></a>6.2.2 线程安全（使用 semaphore 加锁）</h4><p>考虑线程安全的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全：使用 semaphore 加锁</span></span><br><span class="line"><span class="comment"> * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)initTicketStatusSave &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"currentThread---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"semaphore---begin"</span>);</span><br><span class="line">    </span><br><span class="line">    semaphoreLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.ticketSurplusCount = <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// queue1 代表北京火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"net.bujige.testQueue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="comment">// queue2 代表上海火车票售卖窗口</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"net.bujige.testQueue2"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        [weakSelf saleTicketSafe];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 售卖火车票(线程安全)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)saleTicketSafe &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 相当于加锁</span></span><br><span class="line">        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.ticketSurplusCount &gt; <span class="number">0</span>) &#123;  <span class="comment">//如果还有票，继续售卖</span></span><br><span class="line">            <span class="keyword">self</span>.ticketSurplusCount--;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"剩余票数：%d 窗口：%@"</span>, <span class="keyword">self</span>.ticketSurplusCount, [<span class="built_in">NSThread</span> currentThread]]);</span><br><span class="line">            [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">0.2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果已卖完，关闭售票窗口</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"所有火车票均已售完"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 相当于解锁</span></span><br><span class="line">            dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 相当于解锁</span></span><br><span class="line">        dispatch_semaphore_signal(semaphoreLock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果为：</p><p>2018-03-14 16:19:17.386440+0800 GCDDemo1[4000:251186] currentThread—&lt;NSThread: 0x604000074980&gt;{number = 1, name = main}<br>2018-03-14 16:19:17.386660+0800 GCDDemo1[4000:251186] semaphore—begin<br>2018-03-14 16:19:17.387039+0800 GCDDemo1[4000:251241] 剩余票数：49 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}<br>2018-03-14 16:19:17.596014+0800 GCDDemo1[4000:251240] 剩余票数：48 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}<br>2018-03-14 16:19:17.796497+0800 GCDDemo1[4000:251241] 剩余票数：47 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}<br>2018-03-14 16:19:18.000761+0800 GCDDemo1[4000:251240] 剩余票数：46 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}<br>2018-03-14 16:19:18.203361+0800 GCDDemo1[4000:251241] 剩余票数：45 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}</p><p>…</p><p>2018-03-14 16:19:26.745496+0800 GCDDemo1[4000:251241] 剩余票数：3 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}<br>2018-03-14 16:19:26.949711+0800 GCDDemo1[4000:251240] 剩余票数：2 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}<br>2018-03-14 16:19:27.150306+0800 GCDDemo1[4000:251241] 剩余票数：1 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}<br>2018-03-14 16:19:27.353673+0800 GCDDemo1[4000:251240] 剩余票数：0 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}<br>2018-03-14 16:19:27.556782+0800 GCDDemo1[4000:251241] 所有火车票均已售完<br>2018-03-14 16:19:27.557369+0800 GCDDemo1[4000:251240] 所有火车票均已售完</p></blockquote><p>可以看出，在考虑了线程安全的情况下，使用 dispatch_semaphore<br>机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、GCD简介&quot;&gt;&lt;a href=&quot;#一、GCD简介&quot; class=&quot;headerlink&quot; title=&quot;一、GCD简介&quot;&gt;&lt;/a&gt;一、GCD简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Grand Central Dispatch(GCD) 是 Apple 开
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="GCD" scheme="http://yoursite.com/tags/GCD/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>RSS订阅工具</title>
    <link href="http://yoursite.com/2018/03/07/RSS%E8%AE%A2%E9%98%85%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/03/07/RSS订阅工具/</id>
    <published>2018-03-07T07:18:46.000Z</published>
    <updated>2018-03-07T07:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="RSS订阅工具推荐"><a href="#RSS订阅工具推荐" class="headerlink" title="RSS订阅工具推荐"></a>RSS订阅工具推荐</h4><p><a href="http://www.pc6.com/wenjian/ydq/" target="_blank" rel="noopener">RSS工具大全</a></p><p><strong>推荐使用：</strong> <a href="http://www.smzy.com/mac/317267.html" target="_blank" rel="noopener">Breaking</a> （中文， 页面简洁）</p><p><strong>将你喜欢的博客地址复制到Breaking中的搜索框中，会自动订阅，方便关注博客的动态</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;RSS订阅工具推荐&quot;&gt;&lt;a href=&quot;#RSS订阅工具推荐&quot; class=&quot;headerlink&quot; title=&quot;RSS订阅工具推荐&quot;&gt;&lt;/a&gt;RSS订阅工具推荐&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.pc6.com/wenjian/ydq/&quot; 
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="RSS" scheme="http://yoursite.com/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建（二）-- 使用next主题配置博客基本信息</title>
    <link href="http://yoursite.com/2018/03/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2018/03/02/博客搭建（二）-- 使用next主题配置博客基本信息/</id>
    <published>2018-03-02T01:36:14.000Z</published>
    <updated>2018-03-16T09:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在上篇文章中提到了如何免费通过github和hexo创建一个自己的博客，在此将通过next为例，演示一遍配置的过程（喜欢其他主题的可以在此绕过了）</p></blockquote><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h4 id="常用命令及文件地址："><a href="#常用命令及文件地址：" class="headerlink" title="常用命令及文件地址："></a>常用命令及文件地址：</h4><pre><code>部署到本地预览查看三部曲：hexo clean （清除缓存）hexo g (生成静态网页)hexo s (本地启动预览查看)部署到git服务器上：hexo deploy 博客配置文件地址：~/blog/_config.yml主题配置文件地址~/blog/themes/next/_config.yml</code></pre><p>后面不再重复解释</p><h2 id="二、next主题的安装和基本配置"><a href="#二、next主题的安装和基本配置" class="headerlink" title="二、next主题的安装和基本配置"></a>二、next主题的安装和基本配置</h2><h3 id="（一）安装"><a href="#（一）安装" class="headerlink" title="（一）安装"></a>（一）安装</h3><p>首先从github上clone到本地，在终端cd 到blog文件夹（即你通过Hexo init生成的根目录），然后在终端输入命令：</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p>进入blog的全局配置文件：_config.yml （在blog文件夹下 /blog/_config.yml）</p><p>找到theme字段：设置为</p><pre><code>theme: next</code></pre><p>此时可以查看下主题是否配置成功，执行上面提到的三部曲（ <strong>终端cd到blog文件夹 执行 hexo clean , hexo g , hexo s</strong> ）<br>然后访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>,在本地查看效果，进行预览</p><h3 id="（二）-基本信息的配置"><a href="#（二）-基本信息的配置" class="headerlink" title="（二） 基本信息的配置"></a>（二） 基本信息的配置</h3><p>更多的博客和主题的配置可参考 <a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">hexo官方文档</a> 和 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next主题文档</a>，如不想那么麻烦，可以继续往下看，下面就是我使用的一些常用的功能，足够自己使用了</p><h4 id="1、网站标题、作者、语言"><a href="#1、网站标题、作者、语言" class="headerlink" title="1、网站标题、作者、语言"></a>1、网站标题、作者、语言</h4><p><strong>在博客配置文件_config.yml中进行如下配置</strong></p><pre><code># Sitetitle: 拾忆的技术博客subtitle: 小白的技术成长之路description: 小白的技术成长之路author: 拾忆language: zh-Hanstimezone: Asia/Shanghai （如不填，则表示默认电脑的时区）</code></pre><p>这里设置标题作者名字等信息，其中language一项最好配置成zh-Hans（简体中文），（查看next主题支持哪些语言 可查看~/blog/themes/next/languages文件夹）</p><h4 id="2、next主题的风格设置"><a href="#2、next主题的风格设置" class="headerlink" title="2、next主题的风格设置"></a>2、next主题的风格设置</h4><p><strong>在主题配置文件_config.yml中进行如下配置</strong></p><p>next默认有四种风格，可根据自己喜欢的样式去设置查看</p><pre><code># Schemes#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini</code></pre><p>我这里使用的是Mist样式，其中#表示注释，使用哪种去掉前面的#即可，后不再说明</p><h4 id="3、设置菜单选项"><a href="#3、设置菜单选项" class="headerlink" title="3、设置菜单选项"></a>3、设置菜单选项</h4><p>打开主题配置文件：</p><p>先奉上我的配置方便大家去参考：</p><pre><code>menu:  home: / || home  categories: /categories || th  about: /about || user  archives: /archives || archive  tags: /tags || tags  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404/ || heartbeat# Enable/Disable menu icons.menu_icons:  enable: true  # Icon Mapping.  home: home  about: user  categories: th  tags: tags  archives: archive</code></pre><p>其中menu表示配置菜单内容，menu_icons表示菜单图片，如需使用图片则在menu中设定值的后面加上 || 图片名</p><p><strong>（1）常用的默认菜单项，其中home和archives两页是系统默认的就有的，其他的需要自己创建，后面会讲到</strong></p><table><thead><tr><th>键值</th><th>设定值</th><th>显示文本（简体中文）</th></tr></thead><tbody><tr><td>home</td><td>home: /</td><td>主页</td><td></td></tr><tr><td>archives</td><td>archives: /</td><td>归档页</td><td></td></tr><tr><td>categories</td><td>categories: /categories</td><td>分类页</td><td></td></tr><tr><td>tags</td><td>tags: /tags</td><td>标签页</td><td></td></tr><tr><td>about</td><td>about: /about</td><td>关于页面</td><td></td></tr></tbody></table><p><strong>（2）设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。</strong></p><p><strong>以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项：</strong></p><pre><code>menu:  home: 首页  archives: 归档  categories: 分类  tags: 标签  about: 关于</code></pre><p><strong>（3）设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 <a href="http://www.bootcss.com/p/font-awesome/#icons-web-app" target="_blank" rel="noopener">Font Awesome</a> 图标的 名字,去掉前缀icon-(或使用<a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">图标库</a>中的图片名称)。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。next主题默认集成了识别<a href="http://www.bootcss.com/p/font-awesome/#icons-web-app" target="_blank" rel="noopener">Font Awesome</a>图片的方式，只需要在里面找到想要图标的名称，就可以拿过来使用</strong></p><pre><code># Enable/Disable menu icons.menu_icons:  enable: true  # Icon Mapping.  home: home  about: user  categories: th  tags: tags  archives: archive</code></pre><blockquote><p><strong>请注意键值（如 home）的大小写要严格匹配</strong></p></blockquote><h4 id="4、创建上述菜单选项中对应的页面"><a href="#4、创建上述菜单选项中对应的页面" class="headerlink" title="4、创建上述菜单选项中对应的页面"></a>4、创建上述菜单选项中对应的页面</h4><p><strong>（1）分类页面</strong></p><p>终端中cd 进入blog文件夹，执行 <code>hexo new page &quot;categories&quot;</code> 然后在~/blog/source 文件夹中即可看到categories文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）：</p><pre><code>---title: 分类 （title可以自定义）type: categories （记住你写的type类型，后面分类文章需要使用）---</code></pre><p>这时候上一步中菜单项的配置才会生效</p><pre><code>menu:    home: /    archives: /archives    categories: /categories</code></pre><p>这时候如运行本地查看会发现打开后没有任何东西，下面会告诉大家使用方法</p><p><strong>（2）标签页面</strong></p><p>同分类界面相同，终端中cd 进入blog文件夹，执行 <code>hexo new page &quot;tags&quot;</code> 然后在~/blog/source 文件夹中即可看到tags文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）：</p><pre><code>---title: 标签 （title可以自定义）type: tags （记住你写的type类型，后面分类文章需要使用）---</code></pre><p>运行打开后同样什么都不会有</p><p><strong>（3）关于页面</strong></p><p>同理，打开index.md文件后，只需要配置标题即可</p><pre><code>---title: 自我介绍date: 2018-02-28 17:11:54---</code></pre><p>然后下面填写正文即可（这是我使用的方式，但是“关于”界面也可以使用其他方式配置，如配置个链接等，这里大家自行百度即可）</p><h4 id="5、给文章添加分类和标签"><a href="#5、给文章添加分类和标签" class="headerlink" title="5、给文章添加分类和标签"></a>5、给文章添加分类和标签</h4><p>首先创建一个文章，上篇文章末尾有讲到，终端cd 进入blog文件夹，执行 <code>hexo new &quot;文章名字&quot;</code>，打开文章（在~/blog/source/_posts文件夹下）,然后进行如下配置：</p><pre><code>---title: 标题date: 2018-03-02 09:36:14tags: [blog] （注意：使用[]，将需要添加的标签写进去，多个标签用,分隔，categories同理）categories: [blog]---</code></pre><p>保存，此时再去运行查看，点击分类和标签页面就会看到自己的文章了，不再是空的了</p><blockquote><p>但是经过上述操作，发现每创建一篇文章都要在上面去加标签等字段，如果后期功能多的话，可能会要加很多字段，比较麻烦，这里有个比较相对容易的方式不用每次都去添加那些字段<br>首先打开文件 ~/blog/scaffolds/post.md ,进行如下配置：</p></blockquote><pre><code>---title: {{ title }}date: {{ date }}tags: {{ tags }}categories: ---你会发现，之后再创建文章时，文章上方会自动添加这些字段</code></pre><h4 id="6-修改作者头像并旋转"><a href="#6-修改作者头像并旋转" class="headerlink" title="6.修改作者头像并旋转"></a>6.修改作者头像并旋转</h4><p>打开主题配置文件，修改字段 avatar， 值设置成头像的链接地址</p><p>将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）<br>配置为：</p><p><code>avatar: /uploads/avatar.png</code></p><p>或者 放置在 source/images/ 目录下<br>配置为：</p><p><code>avatar: /images/avatar.png</code></p><p>或直接放上链接，如：<br><code>avatar: http://example.com/avatar.png</code></p><p>此时头像设置完成，如需实现旋转效果则按如下过程：</p><p>打开~\blog\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：</p><pre><code>.site-author-image {  display: block;  margin: 0 auto;  padding: $site-author-image-padding;  max-width: $site-author-image-width;  height: $site-author-image-height;  border: $site-author-image-border-width solid $site-author-image-border-color;  /* 头像圆形 */  border-radius: 80px;  -webkit-border-radius: 80px;  -moz-border-radius: 80px;  box-shadow: inset 0 -1px 0 #333sf;  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束     (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/  /* 鼠标经过头像旋转360度 */  -webkit-transition: -webkit-transform 1.0s ease-out;  -moz-transition: -moz-transform 1.0s ease-out;  transition: transform 1.0s ease-out;}img:hover {  /* 鼠标经过停止头像旋转   -webkit-animation-play-state:paused;  animation-play-state:paused;*/  /* 鼠标经过头像旋转360度 */  -webkit-transform: rotateZ(360deg);  -moz-transform: rotateZ(360deg);  transform: rotateZ(360deg);}/* Z 轴旋转动画 */@-webkit-keyframes play {  0% {    -webkit-transform: rotateZ(0deg);  }  100% {    -webkit-transform: rotateZ(-360deg);  }}@-moz-keyframes play {  0% {    -moz-transform: rotateZ(0deg);  }  100% {    -moz-transform: rotateZ(-360deg);  }}@keyframes play {  0% {    transform: rotateZ(0deg);  }  100% {    transform: rotateZ(-360deg);  }}</code></pre><h4 id="7-头像下方添加自己的github等信息"><a href="#7-头像下方添加自己的github等信息" class="headerlink" title="7.头像下方添加自己的github等信息"></a>7.头像下方添加自己的github等信息</h4><p>打开主题配置文件，找到social字段，配置如下，大家可根据自己情况去配置，图片的使用方法同菜单栏一样</p><pre><code>social:  GitHub: https://github.com/username || github  #E-Mail:   #Google: https://plus.google.com/yourname || google  #Twitter: https://twitter.com/yourname || twitter  #FB Page: https://www.facebook.com/yourname || facebook  #VK Group: https://vk.com/yourname || vk  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow  #YouTube: https://youtube.com/yourname || youtube  #Instagram: https://instagram.com/yourname || instagram  #Skype: skype:yourname?call|chat || skypesocial_icons:  enable: true  #icons_only: false  #transition: false  GitHub: github</code></pre><h4 id="8-给站点添加友情链接功能"><a href="#8-给站点添加友情链接功能" class="headerlink" title="8.给站点添加友情链接功能"></a>8.给站点添加友情链接功能</h4><p>打开主题配置文件，进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">links_title: 友情链接</span><br><span class="line">links:</span><br><span class="line">    #百度: http://www.baidu.com/</span><br><span class="line">    #新浪: http://example.com/</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">##  三、next主题的高级配置和一些炫酷的效果</span><br><span class="line"></span><br><span class="line">### （一） 增加评论系统</span><br><span class="line"></span><br><span class="line">百度了一下最新的消息，当前版本的next主题中已经内置支持了各种各样的评论系统，但由于政策的原因（需要实名评论），导致大多数的评论插件都已经失效了，而国外的一些加载比较慢。</span><br><span class="line"></span><br><span class="line">这里附上gitment的评论集成方式[集成流程](https://jingyan.baidu.com/article/2f9b480de2b5b341cb6cc2be.html)</span><br><span class="line"></span><br><span class="line">**gitment**（依托于github issue，能够自己管理，而且被墙的概率小），不过兼容性不太好（需要chrome内核才行），本人使用的gitment，有一个小问题，就是每次发布文章时需要登录下自己的github账号去初始化一下评论，评论功能才能使用，否则会提示“未开放评论”</span><br><span class="line"></span><br><span class="line">**Hypercomments** 是国外的一个第三方评论平台</span><br><span class="line"></span><br><span class="line">**多说** 在2017年06月01日就关闭评论服务了</span><br><span class="line"></span><br><span class="line">**网易云跟贴** 2017年08月01日也停止服务了</span><br><span class="line"></span><br><span class="line">**来必力** (韩国人弄的)总是乱码</span><br><span class="line"></span><br><span class="line">**DISQUS** 外国的，加载慢 </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### （二） 隐藏网页底部powered By Hexo / 强力驱动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">打开主题配置文件，找到如下图位置，将powered设置为 false，theme下的enable 设置为 false</span><br><span class="line"></span><br><span class="line">![picture10](https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/10.png)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### （三） 设置首页文章列表不显示全文(只显示预览)</span><br><span class="line"></span><br><span class="line">* 进入hexo博客项目的themes/next目录</span><br><span class="line">* 打开_config.yml文件</span><br><span class="line">* 搜索&quot;auto_excerpt&quot;,找到如下部分：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Automatically Excerpt. Not recommand.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: false</span><br><span class="line">  length: 150</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">* 把enable改为对应的false改为true，length设置下，然后hexo d -g，再进主页，问题就解决了！</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### （四） 增加本地搜索功能</span><br><span class="line"></span><br><span class="line">#### 添加百度/谷歌/本地 自定义站点内容搜索</span><br><span class="line"></span><br><span class="line">1. 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</span><br><span class="line"></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line">2. 编辑博客配置文件，新增以下内容到任意位置：</span><br><span class="line"></span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br><span class="line">  </span><br><span class="line">3. 编辑主题配置文件，启用本地搜索功能：</span><br><span class="line"></span><br><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### （五） 给 hexo next 主题加上背景图片</span><br><span class="line"></span><br><span class="line">给 hexo next 加上背景图片，只需要在 themes\next\source\css_custom\custom.styl 文件中添加几行代码：</span><br></pre></td></tr></table></figure><p>@media screen and (min-width:1200px) {</p><pre><code>body {background-image:url(/images/background.jpg);background-repeat: no-repeat;background-attachment:fixed;background-position:50% 50%; }#footer a {    color:#eee;}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">repeat、attachment、position就是调整图片的位置，不重复出现、不滚动等等。</span><br><span class="line"></span><br><span class="line">完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。</span><br><span class="line"></span><br><span class="line">那么就需要调整背景的不透明度了。同样是修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码</span><br></pre></td></tr></table></figure></p><p>.main-inner {<br>    margin-top: 60px;<br>    padding: 60px 60px 60px 60px;<br>    background: #fff;<br>    opacity: 0.8;<br>    min-height: 500px;<br>}<br><code>`</code></p><p>background: #fff; 白色</p><p>opacity: 0.8;不透明度</p><h3 id="（六）-其他炫酷效果可参考-hexo的next主题个性化教程-打造炫酷网站"><a href="#（六）-其他炫酷效果可参考-hexo的next主题个性化教程-打造炫酷网站" class="headerlink" title="（六） 其他炫酷效果可参考 hexo的next主题个性化教程:打造炫酷网站"></a>（六） 其他炫酷效果可参考 <a href="https://www.jianshu.com/p/f054333ac9e6" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></h3><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在上篇文章中提到了如何免费通过github和hexo创建一个自己的博客，在此将通过next为例，演示一遍配置的过程（喜欢其他主题的可以在此绕过了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; cl
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建（一）-- 使用Hexo&amp;GitHub免费快速搭建</title>
    <link href="http://yoursite.com/2018/03/01/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89--%20%E4%BD%BF%E7%94%A8Hexo&amp;GitHub%E5%85%8D%E8%B4%B9%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/03/01/博客搭建（一）-- 使用Hexo&amp;GitHub免费快速搭建/</id>
    <published>2018-03-01T02:18:46.000Z</published>
    <updated>2018-03-08T02:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经过两天的折腾，终于搞定了属于自己的第一个博客的搭建，在此期间踩了许多坑，现总结一下帮助各位能够更方便去搭建自己的博客。先贴上成果 <a href="https://lishibo-ios.github.io/" target="_blank" rel="noopener"><strong>拾忆的博客</strong></a></p></blockquote><blockquote><p>百度参考了各路大神的博客文章最后进行的总结，望各路大神不要介意哦~</p></blockquote><blockquote><p>因为本人长期使用mac电脑，故本篇文章只在mac系统的基础上去实现功能，使用Windows系统需要自行参考，其原理是一样的。</p></blockquote><blockquote><p>这是本人写的第一篇文章，可能会看到和其他的许多文章有相似之处，请大家自动忽略(￣▽￣)~* ，全文纯手打，<strong>旨在帮助大家更方便的实现搭建过程</strong>，大家不喜勿喷哦~</p></blockquote><h2 id="一、引子"><a href="#一、引子" class="headerlink" title="一、引子"></a>一、引子</h2><h3 id="1-搭建博客的原因"><a href="#1-搭建博客的原因" class="headerlink" title="1.搭建博客的原因"></a>1.搭建博客的原因</h3><ul><li>曾经用过印象笔记，有道笔记等工具来记录文章，但用起来总是感觉有或多或少的问题，不如用博客看的更直观</li><li>可以随心发表，改造外观，功能</li><li>拥有一个自己的博客网站，感觉更爽</li><li>希望更多的人可以看到自己写的文章</li></ul><h3 id="2-整个过程使用的时间"><a href="#2-整个过程使用的时间" class="headerlink" title="2.整个过程使用的时间"></a>2.整个过程使用的时间</h3><ul><li>最开始百度参考了各路大神的文章，每篇文章都会有或多或少的缺陷，自己又踩了许多坑才完成</li><li>用了大概两天的时间，完成了博客的搭建和主题的修改</li></ul><h3 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3.环境配置"></a>3.环境配置</h3><ul><li>mac系统，sublime编辑器 （暂时使用到的）</li><li>github账号，hexo框架配置，next主题 （下面会提供配置方式）</li></ul><h3 id="4-搭建方式"><a href="#4-搭建方式" class="headerlink" title="4.搭建方式"></a>4.搭建方式</h3><ul><li>使用hexo框架进行网站的构建，然后部署到免费的github上</li></ul><h2 id="二、GitHub配置"><a href="#二、GitHub配置" class="headerlink" title="二、GitHub配置"></a>二、GitHub配置</h2><ol><li><p>登陆 <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> ，没有账号的就去注册一个，记住自己的用户名</p></li><li><p>主页中点击右上角自己的图标，点击your profile</p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/1.png" alt="picture1"></p></li><li><p>点击repositories，新建一个</p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/2.png" alt="picture2"></p></li><li><p>Repository name （填自己的名字） <a href="http://yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了),下图中报错是因为我已经用过了这个名字，大家填写自己的名字不会遇到这个问题，然后点击create" target="_blank" rel="noopener">http://yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了),下图中报错是因为我已经用过了这个名字，大家填写自己的名字不会遇到这个问题，然后点击create</a> repository进行下一步<br> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/3.png" alt="picture3"></p></li><li><p>点击自己的这个repository，然后找到settings</p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/4.png" alt="pictures4"></p></li><li><p>下拉找到GitHub Pages, 其中上面红框中的即为你的博客地址，下面红色框中可以进去选择自己的主题样式, 此时github中的基本配置已经完成 </p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/5.png" alt="picture5"></p><p> 如第一次进入，可能会不显示博客地址，如下图，则可以先选择github自带的主题样式，Choose a theme 按钮，再回来后就能够看到了(<strong>注意：在save按钮左边那项要显示为master branch才表示正确</strong>)</p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/7.png" alt="picture7"></p></li></ol><h2 id="三、环境配置"><a href="#三、环境配置" class="headerlink" title="三、环境配置"></a>三、环境配置</h2><ol><li><p>安装 <a href="http://nodejs.cn/download/" target="_blank" rel="noopener">Node.js</a><br> 安装完成后终端输入 </p><p> <code>node -v</code></p><p>  <code>npm -v</code></p><p>  查看版本号，如存在则表明配置成功</p></li><li><p>mac系统：下载Xcode会自带Git环境，Windows用户需要自行下载<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">Git</a></p></li><li><p>安装完成后，通过git命令查看自己的用户名和邮箱是否和自己github中的一致，如不一致请自行更改，如查询到多个用户名须删除没用的用户名，如查询后没有任何反应则表明还没有配置用户名，用下面的修改或者添加用户名命令即可，如提示其他之类的可先执行命令 <code>git config</code>，然后再执行以下命令即可成功,附查看和更改命令（其他命令可自行百度查找）：</p><p> <strong>查看用户名：</strong> <code>git config --global user.name</code></p><p> <strong>查看邮箱：</strong> <code>git config --global user.email</code></p><p> <strong>删除用户名</strong> <code>git config --global --unset user.name 要删的用户名</code></p><p> <strong>增加用户名</strong> <code>git config —global —add user.name 新加的用户名</code></p><p> <strong>修改用户名</strong> <code>git config --global user.name 用户名</code></p><p> <strong>修改邮箱</strong> <code>git config --global user.email 邮箱</code></p></li><li><p>终端中输入 <code>npm install -g hexo-cli</code>(如提示无权限即下图红色框中permission denied，则输入<code>sudo npm install -g hexo-cli</code>,后输入电脑密码enter即可)</p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/8.png" alt="picture8"></p></li><li><p>这个过程会比较久，如果出现WARN错误可以忽略。我记得当时，每次都会出现说有一个依赖包已经不更新，这个不影响。执行完成后，使用 <code>hexo -v</code> 查看是否安装成功，如下图所示，即表明已经成功安装上</p><p><img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/9.png" alt="picture9"> </p></li></ol><h2 id="四、网站代码以及设置"><a href="#四、网站代码以及设置" class="headerlink" title="四、网站代码以及设置"></a>四、网站代码以及设置</h2><ol><li><p>在桌面上创建一个文件夹，名字自定义如：hexo,终端cd 进入hexo文件夹</p></li><li><p>输入hexo init blog (如出现warn错误可忽略，不影响)</p><ul><li>_config.yml, 网站的配置信息，可以在此配置中配置大部分的参数</li><li>source，资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 </li><li>themes，主题 文件夹。Hexo 会根据主题来生成静态页面。</li></ul></li><li><p>等待提示Start blogging with Hexo，就是安装成功了</p></li><li><p>文件夹中自带一篇文章“Hello World”</p></li><li><p>命令行cd进入blog目录下</p></li><li><p>输入hexo g，生存静态文件</p></li><li><p>输入hexo s，启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><br> 此时服务开启，如需关闭Ctrl+ C</p><blockquote><p>注：hexo s 命令开启的是本地服务，开启后，则可以使用上述地址访问，如关闭，则上述地址访问不到，本功能旨在用来检查修改的配置是否成功，如打开查看后发现没有问题则可以部署到服务器上，之后再用你的博客地址访问即可看到最新的设置效果。</p></blockquote><blockquote><p>如上传服务器之后立即查看博客可能没有立即变化，可尝试多刷新几次或重新打开浏览器即可</p></blockquote></li><li><p>新打开一个终端，输入：ssh-keygen -t rsa -C “Github的注册邮箱地址”</p><p> 一路enter过来，中间有的问题是选y/n的，选y即可，最后得到信息中找到这句话：<br> <code>Your public key has been saved in /Users/zjjk/.ssh/id_rsa.pub.</code></p><p> 找到该文件(上句中in 后面即为该文件的地址)，打开（使用sublime text或其他编辑器）,Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：<a href="https://github.com/settings/keys" target="_blank" rel="noopener">github.com/settings/ssh</a></p><p> 一步步操作：New SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key</p><blockquote><p>注：此过程是生成ssh key，如后续再次执行此命令时，则需要把新生成的SSH key再配置到github中，因为新生成的SSH key会覆盖之前的，如不去github中替换会导致后续上传git服务器过程中失败</p></blockquote></li></ol><h2 id="五、博客网站配置信息"><a href="#五、博客网站配置信息" class="headerlink" title="五、博客网站配置信息"></a>五、博客网站配置信息</h2><ol><li><p>进入blog文件夹，用sublime打开_config.yml文件，此文件为博客的配置信息，在此修改参数。（<strong>特别注意：每个参数的后面都要加个空格</strong>）</p></li><li><p>按照自己的信息进行基础设置</p><p> <code>title: 拾忆的博客</code></p><p> <code>subtitle: 小白的技术成长之路</code> </p><p> <code>description: 小白的技术成长之路</code></p><p> <code>author: 拾忆</code></p><p> <code>language: zh-CN</code></p><p> <code>timezone: Asia/Shanghai</code></p></li><li><p>在_config.yml文件中找到 <code>deploy</code>配置处（一般在最下面，默认的显示可能不全，需按照下方示例自己添加）, username替换成你自己的username, repository的地址为你在github中创建的那个项目的地址，可去github中复制</p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/luzhi4.gif" alt="gif1"></p><pre><code>deploy:       type: git      repository: git@github.com:username/username.github.io.git      branch: master</code></pre><p>  保存完毕。</p></li><li><p>各类主题的配置信息，要在主题文件夹内的_config.yml上进行配置！后续会以next主题为例进行示范，此处可忽略。</p></li></ol><h2 id="六、发表文章"><a href="#六、发表文章" class="headerlink" title="六、发表文章"></a>六、发表文章</h2><ol><li><p>终端 <code>cd</code> 进入blog文件夹下，输入<code>hexo new &quot;Hello blog&quot;</code>(Hello blog为你的文章名，可自定义)</p></li><li><p>打开返回的文件地址，打开文件（也可在blog文件夹下 source/_posts/Hello blog.md 中找到你刚才创建的文件）</p></li><li><p>文章内容采用Markdown语法进行编辑，需要用相关软件才能打开这个文件，本人使用的软件为<a href="http://macdown.uranusjr.com" target="_blank" rel="noopener">MacDown mac版</a>, 大家可根据自己习惯下载喜欢的工具(<strong>附：<a href="http://note.youdao.com/iyoudao/?p=2411&amp;vendor=unsilent14" target="_blank" rel="noopener">Markdown语法使用说明</a></strong>)</p></li><li><p>打开文件编辑</p><pre><code>---title: Hello blogdate: ---</code></pre><p> 只输入title字段即可，后续其他字段可根据主题再添加（<strong>注意：title后面需加空格</strong>）</p></li><li><p>打开终端执行以下步骤:</p><pre><code>cd 进入blog 文件夹$ hexo cleanINFO  Deleted database.INFO  Deleted public folder.$ hexo generateINFO  Start processingINFO  Files loaded in 1.48 s...INFO  29 files generated in 4.27 s$ hexo serverINFO  Start processingINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></pre><p> 此处三步是进行本地配置完成后，在本地打开查看刚刚修改的配置是否修改成功，三处命令也可这样写 <code>hexo clean</code> <code>hexo g</code> <code>hexo s</code> </p></li><li><p>打开 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>后检查，如没有任何问题可以部署到服务器上</p><pre><code> $ hexo deployINFO  Deploying: git</code></pre><p> 此时可能会出现 <code>error deployer not found:git</code> 的错误，输入以下代码 </p><p> <code>npm install hexo-deployer-git --save</code>(如提示无权限错误则输入<code>sudo npm install hexo-deployer-git –-save</code>，后输入电脑密码enter即可)</p><p> 再次执行 <code>hexo deploy</code></p><p> 其中，可能会出现github登录界面，正常填写就行(这里我一直登陆着github，暂时没有遇到)</p><p> 完成，终端可Ctrl+C关闭本地服务，然后打开 username.github.io 即可访问自己的博客（username为自己的github的用户名）</p></li></ol><h2 id="七、主题设置"><a href="#七、主题设置" class="headerlink" title="七、主题设置"></a>七、主题设置</h2><p>主题设置中，最好玩的就是尝试各式各样的主题啦！因本人喜欢next主题的风格，所以会在下篇文章中以next主题为例，走一遍发布文章和配置博客各种信息的流程，下面是其他的一些主题，大家可根据自己喜欢的样式去选择主题下载配置，一般的主题配置都会在其相应的github中说明</p><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方hexo主题大全</a>，里面有许多主题都能尝试一下。</p><p>在这里推荐几个主题：</p><ul><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next官网,Git</a>(我用的就是这个啦，十分推荐！）</li><li><p><a href="https://mt.viosey.com/" target="_blank" rel="noopener">Material官网，Git</a></p><ol><li>主题配置，首先要下载主题，到相应的Git链接</li><li>下载完以后将文件解压缩后放到blog中的themes文件夹中</li><li><p>修改主题文件夹名称，将其改为 next(名称为你的主题的名称，可自定义，无硬性要求，下以next为例) 。 然后打开配置文件（/blog/_config.yml），找到 theme 字段，并将其值更改为 next(你刚才自定义的名称, 注意theme后加空格)，保存关闭</p><p> <img src="https://raw.githubusercontent.com/lishibo-iOS/pictures/master/picture1/6.png" alt="picture6"></p></li><li><p>接下来，打开主题相应的博客中的文档说明，对比“主题”中的_config.yml（ /blog/themes/next/_config.yml ），针对自己需要的功能进行相关设置</p></li><li>有关设置中的图片，统一放到主题文件夹(/next/)内\source\img。在设置中，用”/img/xigua.png”类似格式进行图片设置。</li><li>设置时切记 : 后面要加一个空格。这个坑有点恼人~</li><li>最后再重新进行一次，hexo clean,hexo g,hexo s,hexo deploy 整个博客就完成主题修改啦</li></ol></li></ul><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><ul><li><p>用了两天的时间，完成的博客的搭建，又花了一天时间来编写此篇文章，全文纯手打，写到这里真的好累啊~</p></li><li><p>看着别人的文章一路搭建下来中间还是会遇到很多问题，于是各种百度解决，故在此奉上此文，我遇到的坑这里都明确的解决了，大家也一样，可能会遇到各种不同的问题，百度去一个一个的解决就好了（万能的百度啊~~~）</p></li><li><p>编写文章用了一遍Markdown的语法，感觉还可以</p></li><li><p><a href="https://lishibo-ios.github.io/" target="_blank" rel="noopener">拾忆的博客</a> </p></li><li><p>后续会陆续编写更多的文章，欢迎大家订阅哦~</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;经过两天的折腾，终于搞定了属于自己的第一个博客的搭建，在此期间踩了许多坑，现总结一下帮助各位能够更方便去搭建自己的博客。先贴上成果 &lt;a href=&quot;https://lishibo-ios.github.io/&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS WKWebView基本使用]]></title>
    <url>%2F2018%2F06%2F11%2FWKWebView%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS RunLoop 总结]]></title>
    <url>%2F2018%2F03%2F28%2FiOS%20RunLoop%20%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[RunLoop简介概念 RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。 RunLoop和线程RunLoop和线程是息息相关的，我们知道线程的作用是用来执行特定的一个或多个任务，但是在默认情况下，线程执行完之后就会退出，就不能再执行任务了。这时我们就需要采用一种方式来让线程能够处理任务，并不退出。所以，我们就有了RunLoop。 一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象。 我们只能在当前线程中操作当前线程的RunLoop，而不能去操作其他线程的RunLoop。 RunLoop对象在第一次获取RunLoop时创建，销毁则是在线程结束的时候。 主线程的RunLoop对象系统自动帮助我们创建好了(原理如下)，而子线程的RunLoop对象需要我们主动创建。 默认情况下主线程的RunLoop原理我们在启动一个iOS程序的时候，系统会调用创建项目时自动生成的main.m的文件。main.m文件如下所示： 123456int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 其中UIApplicationMain函数内部帮我们开启了主线程的RunLoop，UIApplicationMain内部拥有一个无线循环的代码。上边的代码中开启RunLoop的过程可以简单的理解为如下代码： 12345678910int main(int argc, char * argv[]) &#123; BOOL running = YES; do &#123; // 执行各种任务，处理各种事件 // ...... &#125; while (running); return 0;&#125; 从上边可看出，程序一直在do-while循环中执行，所以UIApplicationMain函数一直没有返回，我们在运行程序之后程序不会马上退出，会保持持续运行状态。 下图是苹果官方给出的RunLoop模型图: 从上图中可以看出，RunLoop就是线程中的一个循环，RunLoop在循环中会不断检测，通过Input sources（输入源）和Timer sources（定时源）两种来源等待接受事件；然后对接受到的事件通知线程进行处理，并在没有事件的时候进行休息。 RunLoop相关类Core Foundation框架下关于RunLoop的5个类: CFRunLoopRef：代表RunLoop的对象 CFRunLoopModeRef：RunLoop的运行模式 CFRunLoopSourceRef：就是RunLoop模型图中提到的输入源/事件源 CFRunLoopTimerRef：就是RunLoop模型图中提到的定时源 CFRunLoopObserverRef：观察者，能够监听RunLoop的状态改变 附一张关系图： 从图中可以看出这5个类之间的相互关系 一个RunLoop对象（CFRunLoopRef）中包含若干个运行模式（CFRunLoopModeRef）。而每一个运行模式下又包含若干个输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef）。 每次RunLoop启动时，只能指定其中一个运行模式（CFRunLoopModeRef），这个运行模式（CFRunLoopModeRef）被称作CurrentMode。 如果需要切换运行模式（CFRunLoopModeRef），只能退出Loop，再重新指定一个运行模式（CFRunLoopModeRef）进入。 这样做主要是为了分隔开不同组的输入源（CFRunLoopSourceRef）、定时源（CFRunLoopTimerRef）、观察者（CFRunLoopObserverRef），让其互不影响 。 CFRunLoopRefCFRunLoopRef就是Core Foundation框架下RunLoop对象类。我们可通过以下方式来获取RunLoop对象： Core Foundation CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象 CFRunLoopGetMain(); // 获得主线程的RunLoop对象 在Foundation框架下获取RunLoop对象类的方法如下： Foundation [NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象 [NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 CFRunLoopModeRef系统默认定义了多种运行模式（CFRunLoopModeRef），如下： kCFRunLoopDefaultMode：App的默认运行模式，通常主线程是在这个运行模式下运行 UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响） UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到 kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式（后边会用到） 其中kCFRunLoopDefaultMode、UITrackingRunLoopMode、kCFRunLoopCommonModes是我们开发中需要用到的模式，具体使用方法将在下面讲解。 CFRunLoopTimerRefCFRunLoopTimerRef是定时源，理解为基于时间的触发器，基本上就是NSTimer。 下面我们来演示下CFRunLoopModeRef和CFRunLoopTimerRef结合的使用用法，从而加深理解： 新建一个iOS项目，在Main.storyboard中拖入一个Text View 在ViewController.m文件中加入以下代码 1234567891011121314- (void)test1 &#123; // 定义一个定时器，约定两秒之后调用self的run方法 NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES]; // 将定时器添加到当前RunLoop的NSDefaultRunLoopMode下 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; &#125;- (void)run &#123; NSLog(@"====run====");&#125; 然后运行，这时候我们发现如果我们进行任何操作的话，定时器会稳定的每隔2秒调用run方法打印。 但是当我们拖动Text View滚动时，我们发现：run方法不打印了，也就是说NSTimer不工作了。而当我们停止拖动后，NSTimer就又开始正常工作了。 这是因为： 当我们不做任何操作的时候，RunLoop处于NSDefaultRunLoopMode下。 而当我们拖动Text View的时候，RunLoop就结束NSDefaultRunLoopMode，切换到了UITrackingRunLoopMode模式下，这个模式下没有添加NSTimer，所以我们的NSTimer就不工作了。 但当我们松开时，RunLoop就结束UITrackingRunLoopMode模式，又切换回NSDefaultRunLoopMode模式，所以NSTimer就又开始正常工作了。 如果将上述代码中的 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; 语句换为 [[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; ，也就是将定时器添加到当前RunLoop的UITrackingRunLoopMode下，会发现定时器只会在拖动Text View的模式下工作，而不做操作的时候定时器就不工作。 如果想让NSTimer两种模式下都能正常工作，我们就可以用到之前说过的伪模式（kCFRunLoopCommonModes）了，这其实不是一种真实的模式，而是一种标记模式，意思就是可以在打上Common Modes标记的模式下运行。 那么哪些模式被标记上了Common Modes呢？ NSDefaultRunLoopMode 和 UITrackingRunLoopMode。 所以我们只要我们将NSTimer添加到当前RunLoop的kCFRunLoopCommonModes（Foundation框架下为NSRunLoopCommonModes）下，我们就可以让NSTimer在不做操作和拖动Text View两种情况下愉快的正常工作了。 具体做法就是讲添加语句改为 [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 这里顺便讲下NSTimer中的scheduledTimerWithTimeInterval方法和RunLoop的关系: 1[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES]; 这句代码调用了scheduledTimer返回的定时器，NSTimer会自动被加入到了RunLoop的NSDefaultRunLoopMode模式下,就等同于如下代码： 123NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; CFRunLoopSourceRefCFRunLoopSourceRef是事件源（RunLoop模型图中提到过），CFRunLoopSourceRef有两种分类方法。 第一种按照官方文档来分类（就像RunLoop模型图中那样）： Port-Based Sources（基于端口） Custom Input Sources（自定义） Cocoa Perform Selector Sources 第二种按照函数调用栈来分类： Source0 ：非基于Port Source1：基于Port，通过内核和其他线程通信，接收、分发系统事件 这两种分类方式其实没有区别，只不过第一种是通过官方理论来分类，第二种是在实际应用中通过调用函数来分类。 CFRunLoopObserverRefCFRunLoopObserverRef是观察者，用来监听RunLoop的状态改变，可以监听的状态改变有以下几种： 12345678910typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop：1 kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer：2 kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source：4 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠：32 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 即将从休眠中唤醒：64 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将从Loop中退出：128 kCFRunLoopAllActivities = 0x0FFFFFFFU // 监听全部状态改变 &#125;; 下边我们通过代码来监听下RunLoop中的状态改变: 123456789101112131415- (void)test2 &#123; // 创建观察者 CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; NSLog(@"监听到RunLoop发生改变---%zd",activity); &#125;); // 添加观察者到当前RunLoop中 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // 释放observer，最后添加完需要释放掉 CFRelease(observer); &#125; 运行结果： 可以看到RunLoop的状态在不断的改变，最终变成了状态 32，也就是即将进入睡眠状态，说明RunLoop之后就会进入睡眠状态 RunLoop原理首先附上一张图帮助我们理解： 在每次运行开启RunLoop的时候，所在线程的RunLoop会自动处理之前未处理的事件，并且通知相关的观察者。 具体的顺序如下： 通知观察者RunLoop已经启动 通知观察者即将要开始的定时器 通知观察者任何即将启动的非基于端口的源 启动任何准备好的非基于端口的源 如果基于端口的源准备好并处于等待状态，立即启动；并进入步骤9 通知观察者线程进入休眠状态 将线程置于休眠直到任一下面的事件发生： 某一事件到达基于端口的源 定时器启动 RunLoop设置的时间已经超时 RunLoop被显示唤醒 通知观察者线程将被唤醒 处理未处理的事件 如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2 如果输入源启动，传递相应的消息 如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2 通知观察者RunLoop结束。 RunLoop实战应用NSTimer的使用可参考上面的详细讲解 ImageView推迟显示有时候，我们会遇到这种情况：当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。 怎么解决这个问题呢？ 这时候，我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法： 监听UIScrollView的滚动因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。 利用PerformSelector设置当前线程的RunLoop的运行模式利用performSelector方法为UIImageView调用setImage:方法，并利用inModes将其设置为RunLoop下NSDefaultRunLoopMode运行模式。代码如下： 12[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@"tupian"] afterDelay:4.0 inModes:NSDefaultRunLoopMode]; 运行程序，然后拖动UIText View，拖动4秒以上，发现过了4秒之后，UIImageView还没有显示图片，当我们松开的时候，则显示图片 这样我们就实现了在拖动完之后，在延迟显示UIImageView。 后台常驻线程（很常用）我们在开发应用程序的过程中，如果后台操作特别频繁，经常会在子线程做一些耗时操作（下载文件、后台播放音乐等），我们最好能让这条线程永远常驻内存。 那么怎么做呢？ 添加一条用于常驻内存的强引用的子线程，在该线程的RunLoop下添加一个Sources，开启RunLoop。 具体实现过程如下： 123456789101112131415161718192021222324252627282930- (void)viewDidLoad &#123; [super viewDidLoad]; [self test3]; &#125;- (void)test3 &#123; // 创建线程，并调用run1方法执行任务 self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(run1) object:nil]; // 开启线程 [self.thread start]; &#125;- (void)run1 &#123; // 这里写任务 NSLog(@"----run1-----"); // 添加下边两句代码，就可以开启RunLoop，之后self.thread就变成了常驻线程，可随时添加任务，并交于RunLoop处理 [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode]; [[NSRunLoop currentRunLoop] run]; // 测试是否开启了RunLoop，如果开启RunLoop，则来不了这里，因为RunLoop开启了循环。 NSLog(@"未开启RunLoop"); &#125; 运行之后发现打印了—-run1—–，而未开启RunLoop则未打印。 这时，我们就开启了一条常驻线程，下边我们来试着添加其他任务，除了之前创建的时候调用了run1方法，我们另外在点击的时候调用run2方法。 那么，我们在touchesBegan中调用PerformSelector，从而实现在点击屏幕的时候调用run2方法。具体代码如下： 123456789- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 利用performSelector，在self.thread的线程中调用run2方法执行任务 [self performSelector:@selector(run2) onThread:self.thread withObject:nil waitUntilDone:NO];&#125;- (void)run2 &#123; NSLog(@"----run2------");&#125; 经过运行测试，除了之前打印的—-run1—–，每当我们点击屏幕，都能调用—-run2——。这样我们就实现了常驻线程的需求。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 总结（七）---- 实际使用]]></title>
    <url>%2F2018%2F03%2F22%2FiOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%83%EF%BC%89----%20%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引言 这里我以工程中使用到一些runtime相关的代码作为例子，供大家参考和使用 基础准备先给NSObject加个分类，封装下方法交换，方便后面使用 下面总结的方法，大家可自行去尝试下效果 给button增加个防止连续重复点击的时间差在 &quot;UIButton+Swiz.h&quot; 中： 123456789101112#import &lt;UIKit/UIKit.h&gt;@interface UIButton (Swiz)//点击间隔@property (nonatomic, assign) NSTimeInterval timeInterval;//用于设置单个按钮是否需要timeInterval @property (nonatomic, assign) BOOL isIgnore;@end 在 &quot;UIButton+Swiz.m&quot; 中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#import "UIButton+Swiz.h"#import "NSObject+Swiz.h"#define defaultInterval 0.3@implementation UIButton (Swiz)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self methodSwizzlingWithOriginalSelector:@selector(sendAction:to:forEvent:) bySwizzledSelector:@selector(sure_SendAction:to:forEvent:)]; &#125;);&#125;- (void)sure_SendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event &#123; if (self.isIgnore) &#123; //不需要timeInterval 被hook [self sure_SendAction:action to:target forEvent:event]; return; &#125; if ([NSStringFromClass(self.class) isEqualToString:@"UIButton"]) &#123; self.timeInterval = self.timeInterval == 0 ? defaultInterval : self.timeInterval; if (self.isIgnoreEvent) &#123; return; &#125;else if (self.timeInterval &gt; 0) &#123; [self performSelector:@selector(resetState) withObject:nil afterDelay:self.timeInterval]; &#125; &#125; self.isIgnoreEvent = YES; [self sure_SendAction:action to:target forEvent:event]; &#125;- (void)resetState &#123; [self setIsIgnoreEvent:NO];&#125;#pragma mark - runtime动态绑定一个isIgnoreEvent属性- (BOOL)isIgnoreEvent &#123; return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setIsIgnoreEvent:(BOOL)isIgnoreEvent &#123; objc_setAssociatedObject(self, @selector(isIgnoreEvent), @(isIgnoreEvent), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;#pragma mark - runtime动态绑定自定义的两个属性- (NSTimeInterval)timeInterval &#123; return [objc_getAssociatedObject(self, _cmd) doubleValue];&#125;- (void)setTimeInterval:(NSTimeInterval)timeInterval &#123; objc_setAssociatedObject(self, @selector(timeInterval), @(timeInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (BOOL)isIgnore &#123; //_cmd == @select(isIgnore); 和set方法里一致 return [objc_getAssociatedObject(self, _cmd) boolValue];&#125;- (void)setIsIgnore:(BOOL)isIgnore &#123; // 注意BOOL类型 需要用OBJC_ASSOCIATION_RETAIN_NONATOMIC 不要用错，否则set方法会赋值出错 objc_setAssociatedObject(self, @selector(isIgnore), @(isIgnore), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 给button增加点击范围在 &quot;UIButton+Swiz.h&quot; 中加入： 123//设置超出自身范围的额外点击区域@property (nonatomic, assign) UIEdgeInsets touchAreaInsets; 在 &quot;UIButton+Swiz.m&quot; 中加入： 12345678910111213141516171819- (UIEdgeInsets)touchAreaInsets &#123; return [objc_getAssociatedObject(self, _cmd) UIEdgeInsetsValue];&#125;- (void)setTouchAreaInsets:(UIEdgeInsets)touchAreaInsets &#123; NSValue *value = [NSValue valueWithUIEdgeInsets:touchAreaInsets]; objc_setAssociatedObject(self, @selector(touchAreaInsets), value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123; UIEdgeInsets touchAreaInsets = self.touchAreaInsets; CGRect bounds = self.bounds; bounds = CGRectMake(bounds.origin.x - touchAreaInsets.left, bounds.origin.y - touchAreaInsets.top, bounds.size.width + touchAreaInsets.left + touchAreaInsets.right, bounds.size.height + touchAreaInsets.top + touchAreaInsets.bottom); return CGRectContainsPoint(bounds, point); &#125; 判断类中是否含有该属性在有些时候我们需要通过KVC去修改某个类的私有变量，但是又不知道该属性是否存在，如果类中不存在该属性，那么通过KVC赋值就会crash，这时我们可以通过运行时进行判断，可在 NSObject 的分类中增加如下方法: 12345678910111213141516171819202122232425/** 判断类中是否含有该属性 @param property 属性名称 @return 判断结果 */- (BOOL)hasProperty:(NSString *)property &#123; BOOL flag = NO; unsigned int count = 0; Ivar *ivars = class_copyIvarList([self class], &amp;count); for (int i = 0; i &lt; count; i++) &#123; const char *propertyName = ivar_getName(ivars[i]); NSString *propertyString = [NSString stringWithUTF8String:propertyName]; if ([propertyString isEqualToString:property]) &#123; flag = YES; break; &#125; &#125; return flag;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 总结（六）---- 使用场景]]></title>
    <url>%2F2018%2F03%2F21%2FiOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89----%20%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[利用KVC进行赋值实现json转model原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。核心方法：在NSObject的分类中添加方法 一键序列化原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。核心方法：在Model的基类中重写方法： 访问私有变量我们知道，OC中没有真正意义上的私有变量和方法，要让成员变量私有，要放在m文件中声明，不对外暴露。如果我们知道这个成员变量的名称，可以通过runtime获取成员变量，再通过getIvar来获取它的值。方法： 修改私有变量的值 给分类添加公共属性这是最常用的一个模式，通常我们会在类声明里面添加属性，但是出于某些需求（如前言描述的情况），我们需要在分类里添加一个或多个属性的话，编译器就会报错，这个问题的解决方案就是使用runtime的关联对象 这样就可以使用这个属性了 「方法替换」常规写法 上边 demo 中写了一大堆 runtime 的 api 在代码里，即不好阅读，也不便于维护。 这里有现成的方案：一个基于 swizzling method 的开源框架 Aspects 。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 总结（五）---- 消息转发]]></title>
    <url>%2F2018%2F03%2F16%2FiOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89----%20%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[方法调用流程 在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式 [receiver message] 转化为一个消息函数的调用，即 objc_msgSend。 当消息发送给一个对象时，objc_msgSend 通过对象的 isa 指针获取到类的结构体，然后在方法分发表里面查找方法的selector。如果没有找到 selector ，则通过objc_msgSend 结构体中的指向父类的指针找到其父类，并在父类的分发表里面查找方法的 selector。依此，会一直沿着类的继承体系到达 NSObject 类。一旦定位到 selector ，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现。如果最后没有定位到 selector，则会走消息转发流程。 消息转发默认情况下，如果是以 [object message] 的方式调用方法，如果 object 无法响应 message 消息时，编译器会报错。但如果是以 perform… 的形式来调用，则需要等到运行时才能确定 object 是否能接收 message 消息。如果不能，则程序崩溃。不过，我们可以采取一些措施，让我们的程序执行特定的逻辑，而避免程序的崩溃。 消息转发机制的步骤： 1. 动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法 +resolveInstanceMethod: (实例方法)或者 +resolveClassMethod: (类方法)。在这个方法中，我们有机会为该未知消息新增一个”处理方法”“。不过使用该方法的前提是我们已经实现了该”处理方法”，只需要在运行时通过 class_addMethod 函数动态添加到类里面就可以了。 测试一下： 打印结果： 2018-03-16 16:14:04.104890+0800 runtimeDemo1[27033:7983789] 123456 2. 备用接收者如果在上一步动态方法解析没有处理或无法处理消息，则Runtime会继续调方法：- (id)forwardingTargetForSelector:(SEL)aSelector ，如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。当然这个对象不能是self自身，否则就是出现无限循环。当然，如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。 在MyClass.m中添加如下方法： 测试一下： 打印结果： 3. 完整消息转发如果在上一步备用接收者还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。此时会调用方法：- (void)forwardInvocation:(NSInvocation *)anInvocation ，对象会创建一个表示消息的 NSInvocation 对象，把与尚未处理的消息有关的全部细节都封装在 anInvocation 中，包括selector，目标(target)和参数。我们可以在 forwardInvocation 方法中选择将消息转发给其它对象。 forwardInvocation:方法的实现有两个任务： 定位可以响应封装在anInvocation中的消息的对象。这个对象不需要能处理所有未知消息。 使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。 还有一个很重要的问题，我们必须重写以下方法：- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector ,消息转发机制使用从这个方法中获取的信息来创建 NSInvocation 对象。因此我们必须重写这个方法，为给定的 selector 提供一个合适的方法签名。 向OtherClass.m中添加如下方法： 向MyClass.m中添加如下方法： 测试一下： 打印结果： 2018-03-16 16:40:38.493453+0800 runtimeDemo1[27044:7993120] 321]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 总结（四）---- Associative介绍及使用]]></title>
    <url>%2F2018%2F03%2F16%2FiOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89----%20Associative%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、Associative概念 在日常的开发中，objective-c有两个扩展的机制：category和associative。而我们日常使用中百分之90都是使用的category作为日常的扩展方法，但是这个方法有很大的局限性：因为它并不能扩展属性。于是我们就需要借助于另外一个属性的扩展机制：associative 二、Associative介绍及使用associative的原理就是把两个对象互相的捆绑、关联起来，使的其中的一个对象成为另外一个对象的一部分。并且我们可以不用使用修改类的定义而为其对象增加储存空间。这就有一个非常大的好处：在我们无法访问到类的源码的时候或者是考虑到二进制兼容性的时候是非常有用的。因为这允许开发者对已经存在的类在扩展中添加自定义的属性，这几乎弥补了Objective-C最大的缺点。 在使用上，associative是基于key的。所以，我们可以为任何的对象增加无数个不同key的associative，每个都使用上不同的key就好了。并且associative是可以保证能被关联的对象在关联对象的整个生命周期都是可用。 注意：由于正常的扩展是不可以扩展属性的，所以我们在使用associative的时候需要导入 #import &lt;objc/runtime.h&gt; 来实现 1. associative方法其中有3个方法： objc_setAssociatedObject objc_getAssociatedObject objc_removeAssociatedObjects 分别表示设置关联，取得关联，移除关联 2. 创建associative创建associative使用的是：objc_setAssociatedObject 。它把一个对象与另外一个对象进行关联。该函数需要四个参数： object（源对象）: The source object for the association. key（关键字）: The key for the association. value（关联的对象） :The value to associate with the key key for object. Pass nil to clear an existing association. policy（关联策略） :The policy for the association. For possible values, see “Associative Object Behaviors.” 2.1 key关键字关于前两个函数中的 key 值是我们需要重点关注的一个点，这个 key 值必须保证是一个对象级别（为什么是对象级别？看完下面的章节你就会明白了）的唯一常量。一般来说，有以下三种推荐的 key 值： 声明 static char kAssociatedObjectKey ，使用 &amp;kAssociatedObjectKey 作为 key 值。 声明 static void *kAssociatedObjectKey = &amp;kAssociatedObjectKey ，使用 kAssociatedObjectKey 作为 key 值。 用 selector ，使用 getter 方法的名称作为 key 值。 关键字是一个void类型的指针。每一个关联的关键字必须是唯一的。通常都是会采用静态变量来作为关键字，但是其中3个方法中一般1，2基本可以忽略，只使用第三种就好了。因为这样可以优雅地解决了计算科学中的两大世界难题之一：命名（另一难题是缓存失效 ）。 2.2 关联策略关联策略表明了相关的对象是通过赋值，保留引用还是复制的方式进行关联的；还有这种关联是原子的还是非原子的。这里的关联策略和声明属性时的很类似。这种关联策略是通过使用预先定义好的常量来表示的。 根据上面引入的文档可以看出属性可以根据定义在枚举类型 objc_AssociationPolicy 上的行为被关联在对象上。 其中有5种枚举值: Behavior（枚举值） @property Equivalent（等同于属性） Description（解释） OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 指定一个关联对象的copy引用，不能被原子化使用 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 指定一个关联对象的强引用，能被原子化使用 OBJC_ASSOCIATION_COPY @property (atomic, copy) 指定一个关联对象的copy引用，能被原子化使用 以 OBJC_ASSOCIATION_ASSIGN 类型关联在对象上的弱引用不代表0 retian 的 weak 弱引用，行为上更像 unsafe_unretained 属性，所以当在你的视线中调用weak 的关联对象时要相当小心 根据WWDC 2011, Session 322发布的内存销毁时间表，被关联的对象在生命周期内要比对象本身释放的晚很多。它们会在被 NSObject -dealloc 调用的object_dispose() 方法中释放 下面以给Person的类别增加一个sonName的属性为例： 测试一下: 打印结果： 2018-03-16 14:45:19.138287+0800 runtimeDemo1[26986:7959679] John === Bird 断开或者说是删除 associative 是 associative 中3个方法中最不常用的一个方法，可以说基本上都不会使用。因为它会断开所有的 associative 关联 此函数的主要目的是在“初试状态”时方便地返回一个对象。你不应该用这个函数来删除对象的属性，因为可能会导致其他客户对其添加的属性也被移除了。 规范的方法是：调用 objc_setAssociatedObject 方法并传入一个 nil 值来清除一个关联。 3. 消息（Message）在面向对象编程中，对象调用方法叫做发送消息。在编译时，应用的源代码就会被编将对象发送消息转换成runtime的 objc_msgSend 函数调用 [receiver message]; 在编译时会转换成类似这样的函数调用： id objc_msgSend(id self, SEL op, ...) 我们是通过编译器来自动转换成运行时代码时，它会根据类型自动转换成下面的其它一个函数： objc_msgSend： 其它普通的消息都会通过该函数来发送 objc_msgSend_stret： 消息中需要有数据结构作为返回值时，会通过该函数来发送消息并接收返回值 objc_msgSendSuper： 与objc_msgSend函数类似，只是它把消息发送给父类实例 objc_msgSendSuper_stret： 与objc_msgSend_stret函数类似，只是它把消息发送给父类实例并接收数组结构作为返回值]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 总结（三）---- 方法调用示例]]></title>
    <url>%2F2018%2F03%2F16%2FiOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89----%20%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[获取对象所有属性名以创建一个Person类为例，进行示例，通过 class_copyPropertyList 方法获取所有的属性名称 创建个Person类 获取类的所有属性名放到数组中 测试一下结果 打印结果： 2018-03-16 10:56:45.165053+0800 runtimeDemo1[26762:7882820] classSize = 482018-03-16 10:56:45.165662+0800 runtimeDemo1[26762:7882820] propertyName == name2018-03-16 10:56:45.165716+0800 runtimeDemo1[26762:7882820] propertyName == array2018-03-16 10:56:45.165760+0800 runtimeDemo1[26762:7882820] propertyName == age2018-03-16 10:56:45.165802+0800 runtimeDemo1[26762:7882820] propertyName == sex 注意：上面提到的 objc_property_t 是一个结构体指针 objc_property *，因此我们声明的 properties 就是二维指针。所以在使用完毕以后，一定要释放内存，否则会造成内存泄露。并且由于runtime使用的是C语言的API，所以我们也需要使用C语言释放内存的方法：free。 获取对象的所有属性名和属性值对于获取对象的所有属性名，在上面的-allProperties方法已经可以拿到了，但是并没有处理获取属性值，下面的方法就是可以获取属性名和属性值，将属性名作为key，属性值作为value 获取类的所有属性名和属性值放到字典中 测试一下： 打印结果： 2018-03-16 11:29:35.840436+0800 runtimeDemo1[26811:7896171] propertyName == name == propertyValue: John2018-03-16 11:29:35.841046+0800 runtimeDemo1[26811:7896171] propertyName == age == propertyValue: 82018-03-16 11:29:35.841134+0800 runtimeDemo1[26811:7896171] propertyName == sex == propertyValue: 0 获取对象的所有方法名 通过class_copyMethodList方法就可以获取所有的方法。并且我们知道，每一个属性都会自动生成一个成员变量和setter以及getter方法 测试一下： 打印结果： 2018-03-16 11:55:37.736846+0800 runtimeDemo1[26834:7903407] 方法名：allPropertyNamesAndValues,参数个数： 22018-03-16 11:55:37.736944+0800 runtimeDemo1[26834:7903407] 方法名：setAge:,参数个数： 32018-03-16 11:55:37.737014+0800 runtimeDemo1[26834:7903407] 方法名：age,参数个数： 22018-03-16 11:55:37.737096+0800 runtimeDemo1[26834:7903407] 方法名：allMethods,参数个数： 22018-03-16 11:55:37.737167+0800 runtimeDemo1[26834:7903407] 方法名：.cxx_destruct,参数个数： 22018-03-16 11:55:37.737239+0800 runtimeDemo1[26834:7903407] 方法名：setName:,参数个数： 32018-03-16 11:55:37.737305+0800 runtimeDemo1[26834:7903407] 方法名：name,参数个数： 22018-03-16 11:55:37.737370+0800 runtimeDemo1[26834:7903407] 方法名：array,参数个数： 22018-03-16 11:55:37.737442+0800 runtimeDemo1[26834:7903407] 方法名：setArray:,参数个数： 32018-03-16 11:55:37.737508+0800 runtimeDemo1[26834:7903407] 方法名：allProperties,参数个数： 22018-03-16 11:55:37.737727+0800 runtimeDemo1[26834:7903407] 方法名：setSex:,参数个数： 32018-03-16 11:55:37.737812+0800 runtimeDemo1[26834:7903407] 方法名：sex,参数个数： 2 我们发现参数个数不匹配，比如 allPropertyNamesAndValues 方法，参数个数应该为0，但实际打印结果为2。根据打印结果可知，无参数时，值就已经是2了。这个在后面会详细讲解。 获取对象的成员变量名称要获取对象的成员变量，可以通过class_copyIvarList方法来获取，通过ivar_getName来获取成员变量的名称。并且我们知道，每一个属性都会自动生成一个成员变量和setter以及getter方法 测试一下： 打印结果： 2018-03-16 13:56:34.321855+0800 runtimeDemo1[26959:7944606] varName == _variableString2018-03-16 13:56:34.322483+0800 runtimeDemo1[26959:7944606] varName == _sex2018-03-16 13:56:34.322550+0800 runtimeDemo1[26959:7944606] varName == _name2018-03-16 13:56:34.322596+0800 runtimeDemo1[26959:7944606] varName == _array2018-03-16 13:56:34.322699+0800 runtimeDemo1[26959:7944606] varName == _age 运行时发消息iOS中，可以在运行时发送消息，让接收消息者执行对应的动作。可以使用 objc_msgSend 方法，发送消息。因为 objc_msgSend 是因为只有对象才能发送消息，所以肯定是以objc开头的。 另外：使用运行时发送消息前，必须导入 #import &lt;objc/message.h&gt; 这样就等于把 [p allMethods] 这个方法用底层的方法表示出来，其实 [p allMethods] 也会转成这句代码。此时你会发现很尴尬的一个现象是：编译器会报错。 问题出在：期望的参数为空，但是实际上是有2个参数的。所以我们需要来关闭严格检查来解决这个问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 总结（二）---- 主要函数]]></title>
    <url>%2F2018%2F03%2F16%2FiOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89----%20%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这里注释了runtime中相关的方法释义 后期遇到不认识的方法可在此查询其作用 类相关操作函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 获取类的类名const char * class_getName ( Class cls );// 获取类的父类Class class_getSuperclass ( Class cls );// 判断给定的Class是否是一个元类BOOL class_isMetaClass ( Class cls );// 获取实例大小size_t class_getInstanceSize ( Class cls );// 获取类中指定名称实例成员变量的信息Ivar class_getInstanceVariable ( Class cls, const char *name );// 获取类成员变量的信息Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );// 获取整个成员变量列表Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );// 获取指定的属性objc_property_t class_getProperty ( Class cls, const char *name );// 获取属性列表objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );// 为类添加属性BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );// 替换类的属性void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );// 添加方法BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );// 获取实例方法Method class_getInstanceMethod ( Class cls, SEL name );// 获取类方法Method class_getClassMethod ( Class cls, SEL name );// 获取所有方法的数组Method * class_copyMethodList ( Class cls, unsigned int *outCount );// 替代方法的实现IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );// 返回方法的具体实现IMP class_getMethodImplementation ( Class cls, SEL name );IMP class_getMethodImplementation_stret ( Class cls, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class cls, SEL sel );// 添加协议BOOL class_addProtocol ( Class cls, Protocol *protocol );// 返回类是否实现指定的协议BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );// 返回类实现的协议列表Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );// 获取版本号int class_getVersion ( Class cls );// 设置版本号void class_setVersion ( Class cls, int version ); 实例相关操作函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 返回指定对象的一份拷贝id object_copy ( id obj, size_t size );// 释放指定对象占用的内存id object_dispose ( id obj );// 修改类实例的实例变量的值Ivar object_setInstanceVariable ( id obj, const char *name, void *value );// 获取对象实例变量的值Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );// 返回指向给定对象分配的任何额外字节的指针void * object_getIndexedIvars ( id obj );// 返回对象中实例变量的值id object_getIvar ( id obj, Ivar ivar );// 设置对象中实例变量的值void object_setIvar ( id obj, Ivar ivar, id value );// 返回给定对象的类名const char * object_getClassName ( id obj );// 返回对象的类Class object_getClass ( id obj );// 设置对象的类Class object_setClass ( id obj, Class cls );// 获取已注册的类定义的列表int objc_getClassList ( Class *buffer, int bufferCount );// 创建并返回一个指向所有已注册类的指针列表Class * objc_copyClassList ( unsigned int *outCount );// 返回指定类的类定义Class objc_lookUpClass ( const char *name );Class objc_getClass ( const char *name );Class objc_getRequiredClass ( const char *name );// 返回指定类的元类Class objc_getMetaClass ( const char *name );// 设置关联对象void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );// 获取关联对象id objc_getAssociatedObject ( id object, const void *key );// 移除关联对象void objc_removeAssociatedObjects ( id object );// 获取所有加载的Objective-C框架和动态库的名称const char ** objc_copyImageNames ( unsigned int *outCount );// 获取指定类所在动态库const char * class_getImageName ( Class cls );// 获取指定库或框架中所有类的类名const char ** objc_copyClassNamesForImage ( const char *image, unsigned int *outCount ); 属性操作相关函数1234567891011// 获取属性名const char * property_getName ( objc_property_t property );// 获取属性特性描述字符串const char * property_getAttributes ( objc_property_t property );// 获取属性中指定的特性char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );// 获取属性的特性列表objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount ); 方法操作相关函数1234567891011121314151617181920212223242526272829303132333435363738// 调用指定方法的实现id method_invoke ( id receiver, Method m, ... );// 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );// 获取方法名SEL method_getName ( Method m );// 返回方法的实现IMP method_getImplementation ( Method m );// 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );// 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );// 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );// 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );// 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );// 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );// 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );// 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );// 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 ); 选择器相关的操作函数1234567891011// 返回给定选择器指定的方法的名称const char * sel_getName ( SEL sel );// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器SEL sel_registerName ( const char *str );// 在Objective-C Runtime系统中注册一个方法SEL sel_getUid ( const char *str );// 比较两个选择器BOOL sel_isEqual ( SEL lhs, SEL rhs ); 协议相关的操作函数1234567891011121314151617181920212223242526272829303132333435363738394041424344// 返回指定的协议Protocol * objc_getProtocol ( const char *name );// 获取运行时所知道的所有协议的数组Protocol ** objc_copyProtocolList ( unsigned int *outCount );// 创建新的协议实例Protocol * objc_allocateProtocol ( const char *name );// 在运行时中注册新创建的协议void objc_registerProtocol ( Protocol *proto );// 为协议添加方法void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );// 添加一个已注册的协议到协议中void protocol_addProtocol ( Protocol *proto, Protocol *addition );// 为协议添加属性void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );// 返回协议名const char * protocol_getName ( Protocol *p );// 测试两个协议是否相等BOOL protocol_isEqual ( Protocol *proto, Protocol *other );// 获取协议中指定条件的方法的方法描述数组struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );// 获取协议中指定方法的方法描述struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );// 获取协议中的属性列表objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );// 获取协议的指定属性objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );// 获取协议采用的协议Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );// 查看协议是否采用了另一个协议BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other ); block块相关的操作函数12345678// 创建一个指针函数的指针，该函数调用时会调用特定的blockIMP imp_implementationWithBlock ( id block );// 返回与IMP(使用imp_implementationWithBlock创建的)相关的blockid imp_getBlock ( IMP anImp );// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝BOOL imp_removeBlock ( IMP anImp ); 拦截调用函数拦截调用就是在找不到调用的方法程序崩溃之前，有机会通过重写NSObject的四个方法来处理： 1+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 调用一个不存在的类方法的时候，会调用这个方法，默认返回NO，可以加上自己的处理后返回YES 1+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 和上一个方法类似，处理的是实例方法 1- (id)forwardingTargetForSelector:(SEL)aSelector OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0); 将你调用的不存在的方法重定向到一个其他声明了这个方法的类，只需要返回一个有这个方法的target 1- (void)forwardInvocation:(NSInvocation *)anInvocation OBJC_SWIFT_UNAVAILABLE(""); 将你调用的不存在的方法打包成NSInvocation传给你。做完你自己的处理后，调用invokeWithTarget:方法让某个target触发这个方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS runtime 总结（一）---- 基础成员]]></title>
    <url>%2F2018%2F03%2F15%2FiOS%20runtime%20%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89----%20%E5%9F%BA%E7%A1%80%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[runtime 简介Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。比如： [receiver message]; 底层运行时会被编译器转化为： objc_msgSend(receiver, selector) 如果其还有参数比如： [receiver message:(id)arg...]; 底层运行时会被编译器转化为： objc_msgSend(receiver, selector, arg1, arg2, ...) 以上你可能看不出它的价值，但是我们需要了解的是 Objective-C 是一门动态语言，它会将一些工作放在代码运行时才处理而并非编译时。也就是说，有很多类和成员变量在我们编译的时是不知道的，而在运行时，我们所编写的代码会转换成完整的确定的代码运行。 因此，编译器是不够的，我们还需要一个运行时系统(Runtime system)来处理编译后的代码。 Runtime 基本是用 C 和汇编写的，由此可见苹果为了动态系统的高效而做出的努力。 在Objective-C代码中使用Runtime, 需要引入 #import &lt;objc/runtime.h&gt; runtime 作用及相关应用1. runtime作用runtime是属于OC的底层, 可以进行一些非常底层的操作(用OC是无法现实的, 不好实现)。 在程序运行过程中, 动态创建一个类(比如KVO的底层实现) 在程序运行过程中, 动态地为某个类添加属性\方法, 修改属性值\方法 遍历一个类的所有成员变量(属性)\所有方法 2. runtime相关应用 NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性) 字典 –&gt; 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上) KVO(利用runtime动态产生一个类) 用于封装框架(想怎么改就怎么改) runtime 成员1. Class - 类Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。objc_class结构体的定义如下 12345678910111213141516171819202122232425262728293031struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; // 指向metaclass#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 指向父类的指针，如果该类是根类（如NSObject或NSProxy），那么super_class就为NULL const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识。如CLS_CLASS (0x1L) 表示该类为普通 class ，其中包含实例方法和变量;CLS_META (0x2L) 表示该类为 metaclass，其中包含类方法; long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小(包括从父类继承下来的实例变量) struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表，用于存储每个成员变量的地址 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表，如CLS_CLASS (0x1L),则存储实例方法，如CLS_META (0x2L)，则存储类方法 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，用于提升效率； struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 存储该类声明遵守的协议#endif&#125; OBJC2_UNAVAILABLE; 对对象进行操作的方法一般以object_开头 对类进行操作的方法一般以class_开头 对类或对象的方法进行操作的方法一般以method_开头 对成员变量进行操作的方法一般以ivar_开头 对属性进行操作的方法一般以property_开头开头 对协议进行操作的方法一般以protocol_开头 2. 实例对象即objc_object表示的一个类的实例的结构体，它的定义如下 1234567struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;typedef struct objc_object *id; 3. 元类(Meta Class)meta-class是一个类对象的类。它存储着一个类的所有类方法。每个类都会有一个单独的meta-class。 4. isa指针isa是一个指向结构体的指针： 实例对象中的isa指针指向对象所属类Class,这个Class中存储着成员变量和对象方法（“-”方法） Class中的isa指针指向元类，存储着static类型成员变量和类方法（“+”方法）。 5. 方法调用过程 调用对象的实例方法： 先在自身isa指针指向的类（class）methodLists中查找该方法 如果找不到则会通过class的super_class指针找到父类的类对象结构体，然后从methodLists中查找该方法 如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根class 最后响应该方法，最后把该方法添加到cache列表中，以后再调用该方法，直接从cache中取出相应的方法调用 如果一直到根类还没有找到，转向拦截调用 如果没有重写拦截调用的方法，程序报错 调用类方法： 先通过自己的isa指针找到metaclass，并从其中methodLists中查找该类方法 如果找不到则会通过metaclass的super_class指针找到父类的metaclass对象结构体，然后从methodLists中查找该方法 如果仍然找不到，则继续通过super_class向上一级父类结构体中查找，直至根metaclass 最后响应该方法，最后把该方法添加到cache列表中，以后再调用该方法，直接从cache中取出相应的方法调用 如果一直到根类还没有找到，转向拦截调用 如果没有重写拦截调用的方法，程序报错 6.supersuper与self不同，self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。而super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用viewDidLoad方法时，去调用父类的方法，而不是本类中的方法。而它实际上与self指向的是相同的消息接收者。super的定义： 1234struct objc_super &#123; id receiver;//即消息的实际接收者 Class superClass;//指针当前类的父类 &#125;; 例证： 12345- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@"self:%@ super:%@", self, super.class);&#125; 打印结果： 2018-03-15 14:57:42.775938+0800 runtimeDemo1[4540:155849] self:&lt;ViewController: 0x7fb039d07160&gt; super:ViewController 7.SELSEL又叫选择器，是表示一个方法的selector的指针，本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。其定义如下： typedef struct objc_selector *SEL; 8.IMPIMP实际上是一个函数指针，指向方法实现的首地址。SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。其定义如下： id (*IMP)(id, SEL, ...) 9. Method即objc_method表示的一个结构体，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息。它实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。Method用于表示类定义中的方法，定义如下： 12345678910111213typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; 10. CacheCache主要用来缓存。Cache其实就是一个存储Method的链表，主要是为了优化方法调用的性能。当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。 11. IvarIvar表示类中的实例变量。Ivar其实就是一个指向objc_ivar结构体指针，它包含了变量名(ivar_name)、变量类型(ivar_type)等信息。 可以根据下面的这个例子，更好的理解class之间的关系： 注：关于“v@:”写法可参考iOS学习之Objective-C 2.0 运行时系统编程-8类型编码]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 小技巧 ---- 方法总结]]></title>
    <url>%2F2018%2F03%2F15%2FiOS%20%E5%B0%8F%E6%8A%80%E5%B7%A7%20----%20%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[iOS中一些不常用方法总结：1. 删除navigationController中的某个VC12345678NSMutableArray *tempMarr = [NSMutableArray arrayWithArray:self.navigationController.viewControllers];if (tempMarr.count &gt; 0) &#123; [tempMarr removeObjectAtIndex:tempMarr.count-2]; [self.navigationController setViewControllers:tempMarr animated:NO]; &#125; 2. 将字符串中的字母转化为大写或小写123NSString *str = @&quot;123abcABC&quot;;str = [str uppercaseString]; //转化为大写str = [str lowercaseString]; //转化为小写 3. 判断scrollView滑动方向 这里以判断左右滑动为例，判断上下滑动则将对应的x替换为y即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@interface IntroduceViewController ()&lt;UIScrollViewDelegate&gt;&#123; CGFloat contentOffsetX; CGFloat oldContentOffsetX; CGFloat newContentOffsetX;&#125;//开始拖拽视图- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView &#123; contentOffsetX = scrollView.contentOffset.x; &#125;// 滚动时调用此方法(手指离开屏幕后)- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123; newContentOffsetX = scrollView.contentOffset.x; if (newContentOffsetX &gt; oldContentOffsetX &amp;&amp; oldContentOffsetX &gt; contentOffsetX) &#123; // 向左滚动 if (scrollView.contentOffset.x &gt; (_imageArray.count - 1) * SCREEN_WIDTH) &#123; [self gotoLoginVC]; &#125; &#125;else if (newContentOffsetX &lt; oldContentOffsetX &amp;&amp; oldContentOffsetX &lt; contentOffsetX) &#123; // 向右滚动 &#125;else &#123; &#125; if (scrollView.dragging) &#123; // 拖拽 if ((scrollView.contentOffset.x - contentOffsetX) &gt; 5.0f) &#123; // 向左拖拽 if (scrollView.contentOffset.x &gt; (_imageArray.count - 1) * SCREEN_WIDTH) &#123; [self gotoLoginVC]; &#125; &#125;else if ((contentOffsetX - scrollView.contentOffset.x) &gt; 5.0f) &#123; // 向右拖拽 &#125;else &#123; &#125; &#125; &#125;// 完成拖拽(滚动停止时调用此方法，手指离开屏幕前)- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123; oldContentOffsetX = scrollView.contentOffset.x; &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS多线程 ---- GCD使用总结]]></title>
    <url>%2F2018%2F03%2F14%2FiOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%20----%20GCD%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、GCD简介 Grand Central Dispatch(GCD) 是 Apple 开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。它是一个在线程池模式的基础上执行的并发任务。在 Mac OS X 10.6 雪豹中首次推出，也可在 iOS 4 及以上版本使用。 使用GCD的好处 GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能 GCD 会自动利用更多的 CPU 内核（比如双核、四核） GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 二、GCD 常用术语在 GCD 中，我们通常在 block 里执行任务代码，执行任务有两种方式：同步执行（sync）和异步执行（async）。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。 同步执行（sync）： 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。 只能在当前线程中执行任务，不具备开启新线程的能力。 异步执行（async）： 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。 可以在新的线程中执行任务，具备开启新线程的能力。 举个简单例子：你要打电话给小明和小白。 同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。 而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。 注意：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。 队列（Dispatch Queue）： 这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图： 在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。 串行队列（Serial Dispatch Queue）： 每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务） 并发队列（Concurrent Dispatch Queue）： 可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务） 三、GCD提供的方法GCD 的使用步骤其实很简单，只有两步: 创建一个队列（串行队列或并发队列） 将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行） 1. 队列的创建/获取方法 可以使用 dispatch_queue_create 来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。DISPATCH_QUEUE_SERIAL 表示串行队列，DISPATCH_QUEUE_CONCURRENT 表示并发队列。 1234// 串行队列的创建方法dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_SERIAL);// 并发队列的创建方法dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_CONCURRENT); 对于串行队列，GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue）。 所有放在主队列中的任务，都会放到主线程中执行。 可使用 dispatch_get_main_queue() 获得主队列。 12// 主队列的获取方法dispatch_queue_t queue = dispatch_get_main_queue(); 对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue）。 可以使用 dispatch_get_global_queue 来获取。需要传入两个参数。第一个参数表示队列优先级，一般用 DISPATCH_QUEUE_PRIORITY_DEFAULT 。第二个参数暂时没用，用 0 即可。 12// 全局并发队列的获取方法dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); 2. 任务的创建方法GCD 提供了同步执行任务的创建方法 dispatch_sync 和异步执行任务创建方法 dispatch_async 。 12345678// 同步执行任务创建方法dispatch_sync(queue, ^&#123; // 这里放同步执行任务代码&#125;);// 异步执行任务创建方法dispatch_async(queue, ^&#123; // 这里放异步执行任务代码&#125;); 虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是： 同步执行 + 并发队列 异步执行 + 并发队列 同步执行 + 串行队列 异步执行 + 串行队列 实际上，刚才还说了两种特殊队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。 同步执行 + 主队列 异步执行 + 主队列 四、GCD的基本使用1. 同步执行 + 并发队列 在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。 123456789101112131415161718192021222324252627282930313233343536/** * 同步执行 + 并发队列 * 特点：在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。 */- (void)syncConcurrent &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"syncConcurrent---begin"); dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_CONCURRENT); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@"syncConcurrent---end");&#125; 输出结果： 2018-03-14 10:48:58.322012+0800 GCDDemo1[1849:70838] currentThread—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}2018-03-14 10:48:58.322214+0800 GCDDemo1[1849:70838] syncConcurrent—begin2018-03-14 10:49:00.322971+0800 GCDDemo1[1849:70838] 1—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}2018-03-14 10:49:02.323947+0800 GCDDemo1[1849:70838] 1—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}2018-03-14 10:49:04.324712+0800 GCDDemo1[1849:70838] 2—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}2018-03-14 10:49:06.325088+0800 GCDDemo1[1849:70838] 2—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}2018-03-14 10:49:08.325530+0800 GCDDemo1[1849:70838] 3—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}2018-03-14 10:49:10.326147+0800 GCDDemo1[1849:70838] 3—&lt;NSThread: 0x60400006b940&gt;{number = 1, name = main}2018-03-14 10:49:10.326585+0800 GCDDemo1[1849:70838] syncConcurrent—end 从 同步执行 + 并发队列 中可看到： 所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（同步执行不具备开启新线程的能力）。 所有任务都在打印的 syncConcurrent---begin 和 syncConcurrent---end 之间执行的（同步任务需要等待队列的任务执行结束）。 任务按顺序执行的。按顺序执行的原因：虽然 并发队列 可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（同步任务不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（同步任务需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。 2. 异步执行 + 并发队列 可以开启多个线程，任务交替（同时）执行。 123456789101112131415161718192021222324252627282930313233343536/** * 异步执行 + 并发队列 * 特点：可以开启多个线程，任务交替（同时）执行。 */- (void)asyncConcurrent &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"asyncConcurrent---begin"); dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@"asyncConcurrent---end");&#125; 输出结果： 2018-03-14 11:01:57.692961+0800 GCDDemo1[1905:78877] currentThread—&lt;NSThread: 0x60000006ccc0&gt;{number = 1, name = main}2018-03-14 11:01:57.719769+0800 GCDDemo1[1905:78877] asyncConcurrent—begin2018-03-14 11:01:57.719990+0800 GCDDemo1[1905:78877] asyncConcurrent—end2018-03-14 11:01:59.721258+0800 GCDDemo1[1905:79082] 1—&lt;NSThread: 0x600000263040&gt;{number = 3, name = (null)}2018-03-14 11:01:59.721264+0800 GCDDemo1[1905:79081] 2—&lt;NSThread: 0x60000026b900&gt;{number = 4, name = (null)}2018-03-14 11:01:59.721296+0800 GCDDemo1[1905:79085] 3—&lt;NSThread: 0x604000278180&gt;{number = 5, name = (null)}2018-03-14 11:02:01.722360+0800 GCDDemo1[1905:79081] 2—&lt;NSThread: 0x60000026b900&gt;{number = 4, name = (null)}2018-03-14 11:02:01.722360+0800 GCDDemo1[1905:79082] 1—&lt;NSThread: 0x600000263040&gt;{number = 3, name = (null)}2018-03-14 11:02:01.722382+0800 GCDDemo1[1905:79085] 3—&lt;NSThread: 0x604000278180&gt;{number = 5, name = (null)} 在 异步执行 + 并发队列 中可以看出： 除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（异步执行具备开启新线程的能力。且并发队列可开启多个线程，同时执行多个任务）。 所有任务是在打印的 syncConcurrent---begin 和 syncConcurrent---end 之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（异步执行不做等待，可以继续执行任务）。 3. 同步执行 + 串行队列 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。 1234567891011121314151617181920212223242526272829303132333435/** * 同步执行 + 串行队列 * 特点：不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。 */- (void)syncSerial &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"syncSerial---begin"); dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_SERIAL); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@"syncSerial---end");&#125; 输出结果为： 2018-03-14 11:06:49.184007+0800 GCDDemo1[1945:82494] currentThread—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}2018-03-14 11:06:49.184219+0800 GCDDemo1[1945:82494] syncSerial—begin2018-03-14 11:06:51.185431+0800 GCDDemo1[1945:82494] 1—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}2018-03-14 11:06:53.186840+0800 GCDDemo1[1945:82494] 1—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}2018-03-14 11:06:55.187418+0800 GCDDemo1[1945:82494] 2—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}2018-03-14 11:06:57.188837+0800 GCDDemo1[1945:82494] 2—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}2018-03-14 11:06:59.189861+0800 GCDDemo1[1945:82494] 3—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}2018-03-14 11:07:01.190613+0800 GCDDemo1[1945:82494] 3—&lt;NSThread: 0x604000072f00&gt;{number = 1, name = main}2018-03-14 11:07:01.191055+0800 GCDDemo1[1945:82494] syncSerial—end 在同步执行 + 串行队列可以看到： 所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（同步执行不具备开启新线程的能力）。 所有任务都在打印的syncConcurrent—begin和syncConcurrent—end之间执行（同步任务需要等待队列的任务执行结束）。 任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。 4. 异步执行 + 串行队列 会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务 1234567891011121314151617181920212223242526272829303132333435/** * 异步执行 + 串行队列 * 特点：会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务。 */- (void)asyncSerial &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"asyncSerial---begin"); dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_SERIAL); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@"asyncSerial---end");&#125; 输出结果为： 2018-03-14 11:10:25.852255+0800 GCDDemo1[1987:85325] currentThread—&lt;NSThread: 0x60400007c0c0&gt;{number = 1, name = main}2018-03-14 11:10:25.852446+0800 GCDDemo1[1987:85325] asyncSerial—begin2018-03-14 11:10:25.852601+0800 GCDDemo1[1987:85325] asyncSerial—end2018-03-14 11:10:27.854119+0800 GCDDemo1[1987:85430] 1—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}2018-03-14 11:10:29.856678+0800 GCDDemo1[1987:85430] 1—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}2018-03-14 11:10:31.860508+0800 GCDDemo1[1987:85430] 2—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}2018-03-14 11:10:33.863252+0800 GCDDemo1[1987:85430] 2—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}2018-03-14 11:10:35.863730+0800 GCDDemo1[1987:85430] 3—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)}2018-03-14 11:10:37.865454+0800 GCDDemo1[1987:85430] 3—&lt;NSThread: 0x600000460280&gt;{number = 3, name = (null)} 在异步执行 + 串行队列可以看到： 开启了一条新线程（异步执行具备开启新线程的能力，串行队列只开启一个线程）。 所有任务是在打印的 syncConcurrent---begin 和 syncConcurrent---end 之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。 任务是按顺序执行的（串行队列每次只有一个任务被执行，任务一个接一个按顺序执行）。 主队列：GCD自带的一种特殊的串行队列 - 所有放在主队列中的任务，都会放到主线程中执行 - 可使用dispatch_get_main_queue()获得主队列 5. 同步执行 + 主队列同步执行 + 主队列 在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。 5.1 在主线程中调用同步执行 + 主队列 互相等待卡住不可行 123456789101112131415161718192021222324252627282930313233343536373839/** * 同步执行 + 主队列 * 特点(主线程调用)：互等卡主不执行。 * 特点(其他线程调用)：不会开启新线程，执行完一个任务，再执行下一个任务。 */- (void)syncMain &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"syncMain---begin"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_sync(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_sync(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@"syncMain---end");&#125; 输出结果 2018-03-14 11:17:39.275258+0800 GCDDemo1[2046:90602] currentThread—&lt;NSThread: 0x60400006e740&gt;{number = 1, name = main}2018-03-14 11:17:39.275437+0800 GCDDemo1[2046:90602] syncMain—begin 在同步执行 + 主队列可以惊奇的发现： 在主线程中使用同步执行 + 主队列，追加到主线程的任务1、任务2、任务3都不再执行了，而且syncMain—end也没有打印，在Xcode 9上还会报崩溃。这是为什么呢？ 这是因为我们在主线程中执行 syncMain 方法，相当于把 syncMain 任务放到了主线程的队列中。而 同步执行 会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把 任务1 追加到主队列中，任务1 就在等待主线程处理完 syncMain 任务。而 syncMain 任务需要等待 任务1 执行完毕，才能接着执行。 那么，现在的情况就是 syncMain 任务和 任务1 都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且 syncMain---end 也没有打印。 5.2 在其他线程中调用同步执行 + 主队列 不会开启新线程，执行完一个任务，再执行下一个任务 123// 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行 selector 任务[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil]; 输出结果： 2018-03-14 11:23:05.466225+0800 GCDDemo1[2080:94606] currentThread—&lt;NSThread: 0x604000270f40&gt;{number = 3, name = (null)}2018-03-14 11:23:05.478127+0800 GCDDemo1[2080:94606] syncMain—begin2018-03-14 11:23:07.480904+0800 GCDDemo1[2080:94470] 1—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}2018-03-14 11:23:09.481443+0800 GCDDemo1[2080:94470] 1—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}2018-03-14 11:23:11.484207+0800 GCDDemo1[2080:94470] 2—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}2018-03-14 11:23:13.486038+0800 GCDDemo1[2080:94470] 2—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}2018-03-14 11:23:15.488007+0800 GCDDemo1[2080:94470] 3—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}2018-03-14 11:23:17.488561+0800 GCDDemo1[2080:94470] 3—&lt;NSThread: 0x60000006a4c0&gt;{number = 1, name = main}2018-03-14 11:23:17.490313+0800 GCDDemo1[2080:94606] syncMain—end 在其他线程中使用同步执行 + 主队列可看到： 所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。 所有任务都在打印的 syncConcurrent---begin 和 syncConcurrent---end 之间执行（同步任务需要等待队列的任务执行结束）。 任务是按顺序执行的（主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。 为什么现在就不会卡住了呢？因为 syncMain 任务 放到了其他线程里，而 任务1、任务2、任务3 都在追加到主队列中，这三个任务都会在主线程中执行。 syncMain 任务 在其他线程中执行到追加 任务1 到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的 任务1 ，等 任务1 执行完毕，再接着执行 任务2、任务3 。所以这里不会卡住线程。 6. 异步执行 + 主队列 只在主线程中执行任务，执行完一个任务，再执行下一个任务。 123456789101112131415161718192021222324252627282930313233343536/** * 异步执行 + 主队列 * 特点：只在主线程中执行任务，执行完一个任务，再执行下一个任务 */- (void)asyncMain &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"asyncMain---begin"); dispatch_queue_t queue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); NSLog(@"asyncMain---end");&#125; 输出结果： 2018-03-14 11:29:40.481045+0800 GCDDemo1[2108:98613] currentThread—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}2018-03-14 11:29:40.481543+0800 GCDDemo1[2108:98613] asyncMain—begin2018-03-14 11:29:40.481784+0800 GCDDemo1[2108:98613] asyncMain—end2018-03-14 11:29:42.489512+0800 GCDDemo1[2108:98613] 1—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}2018-03-14 11:29:44.489838+0800 GCDDemo1[2108:98613] 1—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}2018-03-14 11:29:46.490323+0800 GCDDemo1[2108:98613] 2—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}2018-03-14 11:29:48.491654+0800 GCDDemo1[2108:98613] 2—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}2018-03-14 11:29:50.492748+0800 GCDDemo1[2108:98613] 3—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main}2018-03-14 11:29:52.494553+0800 GCDDemo1[2108:98613] 3—&lt;NSThread: 0x604000078a00&gt;{number = 1, name = main} 在异步执行 + 主队列可以看到： 所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。 所有任务是在打印的 syncConcurrent—begin 和 syncConcurrent—end 之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。 任务是按顺序执行的（因为主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。 五、GCD 线程间的通信在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。 123456789101112131415161718192021222324/** * 线程间通信 */- (void)communication &#123; // 获取全局并发队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); // 获取主队列 dispatch_queue_t mainQueue = dispatch_get_main_queue(); dispatch_async(queue, ^&#123; // 异步追加任务 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; // 回到主线程 dispatch_async(mainQueue, ^&#123; // 追加在主线程中执行的任务 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125;); &#125;);&#125; 输出结果： 2018-03-14 13:50:07.799131+0800 GCDDemo1[2571:160671] 1—&lt;NSThread: 0x604000079900&gt;{number = 3, name = (null)}2018-03-14 13:50:09.800005+0800 GCDDemo1[2571:160671] 1—&lt;NSThread: 0x604000079900&gt;{number = 3, name = (null)}2018-03-14 13:50:11.801108+0800 GCDDemo1[2571:160469] 2—&lt;NSThread: 0x6000000660c0&gt;{number = 1, name = main} 可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。 六、GCD 的其他方法1. GCD 栅栏方法：dispatch_barrier_async 我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到 dispatch_barrier_async 方法在两个操作组间形成栅栏。 dispatch_barrier_async 函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在 dispatch_barrier_async 函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 栅栏方法 dispatch_barrier_async */- (void)barrier &#123; dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_CONCURRENT); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_barrier_async(queue, ^&#123; // 追加任务 barrier for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"barrier---%@",[NSThread currentThread]);// 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务3 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_async(queue, ^&#123; // 追加任务4 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"4---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;);&#125; 输出结果： 2018-03-14 14:08:13.366011+0800 GCDDemo1[2727:170441] 2—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)}2018-03-14 14:08:13.366011+0800 GCDDemo1[2727:170442] 1—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}2018-03-14 14:08:15.370119+0800 GCDDemo1[2727:170441] 2—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)}2018-03-14 14:08:15.370119+0800 GCDDemo1[2727:170442] 1—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}2018-03-14 14:08:17.374574+0800 GCDDemo1[2727:170442] barrier—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}2018-03-14 14:08:19.375400+0800 GCDDemo1[2727:170442] barrier—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}2018-03-14 14:08:21.376229+0800 GCDDemo1[2727:170441] 4—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)}2018-03-14 14:08:21.376229+0800 GCDDemo1[2727:170442] 3—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}2018-03-14 14:08:23.377080+0800 GCDDemo1[2727:170442] 3—&lt;NSThread: 0x60400007b7c0&gt;{number = 3, name = (null)}2018-03-14 14:08:23.377080+0800 GCDDemo1[2727:170441] 4—&lt;NSThread: 0x604000260b40&gt;{number = 4, name = (null)} 在 dispatch_barrier_async 执行结果中可以看出： 在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。 2. GCD 延时执行方法：dispatch_after我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的 dispatch_after 函数来实现。需要注意的是：dispatch_after 函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after 函数是很有效的。 1234567891011121314151617181920212223242526272829303132333435363738/** * 延时执行方法 dispatch_after */- (void)after &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"asyncMain---begin"); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 2.0秒后异步追加任务代码到主队列，并开始执行 NSLog(@"after---%@",[NSThread currentThread]); // 打印当前线程 &#125;);&#125;``` &gt; 输出结果：&gt; 2018-03-14 14:12:45.078709+0800 GCDDemo1[2783:173596] currentThread---&lt;NSThread: 0x60400006c840&gt;&#123;number = 1, name = main&#125;2018-03-14 14:12:45.078902+0800 GCDDemo1[2783:173596] asyncMain---begin2018-03-14 14:12:47.261070+0800 GCDDemo1[2783:173596] after---&lt;NSThread: 0x60400006c840&gt;&#123;number = 1, name = main&#125;可以看出：在打印 `asyncMain---begin` 之后大约 2.0 秒的时间，打印了 `after---&lt;NSThread: 0x60000006ee00&gt;&#123;number = 1, name = main&#125;`### 3. GCD 一次性代码（只执行一次）：dispatch_once- 我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 `dispatch_once` 函数。使用`dispatch_once` 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，`dispatch_once` 也可以保证线程安全。``` objectivec/** * 一次性代码（只执行一次）dispatch_once */- (void)once &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 只执行1次的代码(这里面默认是线程安全的) &#125;);&#125; 4. GCD 快速迭代方法：dispatch_apply 通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数 dispatch_apply。dispatch_apply 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。 如果是在串行队列中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。dispatch_apply 可以 在多个线程中同时（异步）遍历多个数字。还有一点，无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 dispatch_group_wait方法。 123456789101112/** * 快速迭代方法 dispatch_apply */- (void)apply &#123; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); NSLog(@"apply---begin"); dispatch_apply(6, queue, ^(size_t index) &#123; NSLog(@"%zd---%@",index, [NSThread currentThread]); &#125;); NSLog(@"apply---end");&#125; 输出结果： 2018-03-14 14:24:35.502250+0800 GCDDemo1[2885:180445] apply—begin2018-03-14 14:24:35.503352+0800 GCDDemo1[2885:180445] 0—&lt;NSThread: 0x6000000726c0&gt;{number = 1, name = main}2018-03-14 14:24:35.503375+0800 GCDDemo1[2885:180520] 3—&lt;NSThread: 0x60000026f980&gt;{number = 5, name = (null)}2018-03-14 14:24:35.503353+0800 GCDDemo1[2885:180524] 1—&lt;NSThread: 0x60000026fb00&gt;{number = 3, name = (null)}2018-03-14 14:24:35.503394+0800 GCDDemo1[2885:180523] 2—&lt;NSThread: 0x60000026fc00&gt;{number = 4, name = (null)}2018-03-14 14:24:35.503600+0800 GCDDemo1[2885:180524] 4—&lt;NSThread: 0x60000026fb00&gt;{number = 3, name = (null)}2018-03-14 14:24:35.503606+0800 GCDDemo1[2885:180520] 5—&lt;NSThread: 0x60000026f980&gt;{number = 5, name = (null)}2018-03-14 14:24:35.503725+0800 GCDDemo1[2885:180445] apply—end 因为是在并发队列中异步队执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是 apply---end一 定在最后执行。这是因为 dispatch_apply 函数会等待全部任务执行完毕。 5. GCD 的队列组：dispatch_group有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。 调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合 来实现 dispatch_group_async。 调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）。 5.1 dispatch_group_notify 监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。 12345678910111213141516171819202122232425262728293031323334/** * 队列组 dispatch_group_notify */- (void)groupNotify &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"group---begin"); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; NSLog(@"group---end"); &#125;);&#125; 输出结果： 2018-03-14 15:14:56.708549+0800 GCDDemo1[3363:210384] currentThread—&lt;NSThread: 0x600000262600&gt;{number = 1, name = main}2018-03-14 15:14:56.708977+0800 GCDDemo1[3363:210384] group—begin2018-03-14 15:14:58.713556+0800 GCDDemo1[3363:210541] 2—&lt;NSThread: 0x604000460ec0&gt;{number = 4, name = (null)}2018-03-14 15:14:58.713556+0800 GCDDemo1[3363:210543] 1—&lt;NSThread: 0x604000461740&gt;{number = 3, name = (null)}2018-03-14 15:15:00.718094+0800 GCDDemo1[3363:210541] 2—&lt;NSThread: 0x604000460ec0&gt;{number = 4, name = (null)}2018-03-14 15:15:00.718094+0800 GCDDemo1[3363:210543] 1—&lt;NSThread: 0x604000461740&gt;{number = 3, name = (null)}2018-03-14 15:15:02.719004+0800 GCDDemo1[3363:210384] 3—&lt;NSThread: 0x600000262600&gt;{number = 1, name = main}2018-03-14 15:15:04.720260+0800 GCDDemo1[3363:210384] 3—&lt;NSThread: 0x600000262600&gt;{number = 1, name = main}2018-03-14 15:15:04.720453+0800 GCDDemo1[3363:210384] group—end 从 dispatch_group_notify 相关代码运行输出结果可以看出：当所有任务都执行完成之后，才执行 dispatch_group_notify block 中的任务。 5.2 dispatch_group_wait 暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。 123456789101112131415161718192021222324252627282930/** * 队列组 dispatch_group_wait */- (void)groupWait &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"group---begin"); dispatch_group_t group = dispatch_group_create(); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; &#125;); // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程） dispatch_group_wait(group, DISPATCH_TIME_FOREVER); NSLog(@"group---end");&#125; 输出结果： 2018-03-14 15:19:06.067937+0800 GCDDemo1[3413:213407] currentThread—&lt;NSThread: 0x600000262000&gt;{number = 1, name = main}2018-03-14 15:19:06.068098+0800 GCDDemo1[3413:213407] group—begin2018-03-14 15:19:08.072494+0800 GCDDemo1[3413:213491] 1—&lt;NSThread: 0x600000471640&gt;{number = 3, name = (null)}2018-03-14 15:19:08.072494+0800 GCDDemo1[3413:213490] 2—&lt;NSThread: 0x60400027b2c0&gt;{number = 4, name = (null)}2018-03-14 15:19:10.077314+0800 GCDDemo1[3413:213490] 2—&lt;NSThread: 0x60400027b2c0&gt;{number = 4, name = (null)}2018-03-14 15:19:10.077314+0800 GCDDemo1[3413:213491] 1—&lt;NSThread: 0x600000471640&gt;{number = 3, name = (null)}2018-03-14 15:19:10.077544+0800 GCDDemo1[3413:213407] group—end 从 dispatch_group_wait 相关代码运行输出结果可以看出：当所有任务执行完成之后，才执行 dispatch_group_wait 之后的操作。但是，使用 dispatch_group_wait 会阻塞当前线程。 5.3 dispatch_group_enter、dispatch_group_leave dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1 dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。 当 group 中未执行完毕任务数为0的时候，才会使 dispatch_group_wait 解除阻塞，以及执行追加到 dispatch_group_notify 中的任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 队列组 dispatch_group_enter、dispatch_group_leave */- (void)groupEnterAndLeave&#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"group---begin"); dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_group_enter(group); dispatch_async(queue, ^&#123; // 追加任务1 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 &#125; dispatch_group_leave(group); &#125;); dispatch_group_enter(group); dispatch_async(queue, ^&#123; // 追加任务2 for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@",[NSThread currentThread]); // 打印当前线程 &#125; dispatch_group_leave(group); &#125;); dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; // 等前面的异步操作都执行完毕后，回到主线程. for (int i = 0; i &lt; 2; ++i) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@",[NSThread currentThread]); // 打印当前线程 &#125; NSLog(@"group---end"); &#125;); // // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）// dispatch_group_wait(group, DISPATCH_TIME_FOREVER);//// NSLog(@"group---end");&#125; 输出结果： 2018-03-14 15:36:54.609837+0800 GCDDemo1[3574:223779] currentThread—&lt;NSThread: 0x600000073880&gt;{number = 1, name = main}2018-03-14 15:36:54.610131+0800 GCDDemo1[3574:223779] group—begin2018-03-14 15:36:56.615708+0800 GCDDemo1[3574:223890] 2—&lt;NSThread: 0x6040004611c0&gt;{number = 3, name = (null)}2018-03-14 15:36:56.615711+0800 GCDDemo1[3574:223894] 1—&lt;NSThread: 0x600000269a80&gt;{number = 4, name = (null)}2018-03-14 15:36:58.620700+0800 GCDDemo1[3574:223890] 2—&lt;NSThread: 0x6040004611c0&gt;{number = 3, name = (null)}2018-03-14 15:36:58.620703+0800 GCDDemo1[3574:223894] 1—&lt;NSThread: 0x600000269a80&gt;{number = 4, name = (null)}2018-03-14 15:37:00.621517+0800 GCDDemo1[3574:223779] 3—&lt;NSThread: 0x600000073880&gt;{number = 1, name = main}2018-03-14 15:37:02.621943+0800 GCDDemo1[3574:223779] 3—&lt;NSThread: 0x600000073880&gt;{number = 1, name = main}2018-03-14 15:37:02.622138+0800 GCDDemo1[3574:223779] group—end 从 dispatch_group_enter、dispatch_group_leave 相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的 dispatch_group_enter、dispatch_group_leave 组合，其实等同于 dispatch_group_async。 6. GCD 信号量：dispatch_semaphoreGCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。 Dispatch Semaphore 提供了三个函数： dispatch_semaphore_create: 创建一个Semaphore并初始化信号的总量 dispatch_semaphore_signal: 发送一个信号，让信号总量加1 dispatch_semaphore_wait: 可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。 注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。 Dispatch Semaphore 在实际开发中主要用于： 保持线程同步，将异步执行任务转换为同步执行任务 保证线程安全，为线程加锁 6.1 Dispatch Semaphore 线程同步我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。 123456789101112131415161718192021- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123; __block NSArray *tasks = nil; dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123; tasks = dataTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123; tasks = uploadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123; tasks = downloadTasks; &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123; tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@"@unionOfArrays.self"]; &#125; dispatch_semaphore_signal(semaphore); &#125;]; dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); return tasks;&#125; 下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。 12345678910111213141516171819202122232425/** * semaphore 线程同步 */- (void)semaphoreSync &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"semaphore---begin"); dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); __block int number = 0; dispatch_async(queue, ^&#123; // 追加任务1 [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@",[NSThread currentThread]); // 打印当前线程 number = 100; dispatch_semaphore_signal(semaphore); &#125;); dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSLog(@"semaphore---end,number = %zd",number);&#125; 输出结果： 2018-03-14 16:02:54.230308+0800 GCDDemo1[3783:239611] currentThread—&lt;NSThread: 0x604000066500&gt;{number = 1, name = main}2018-03-14 16:02:54.230478+0800 GCDDemo1[3783:239611] semaphore—begin2018-03-14 16:02:56.235662+0800 GCDDemo1[3783:239848] 1—&lt;NSThread: 0x604000270980&gt;{number = 3, name = (null)}2018-03-14 16:02:56.236054+0800 GCDDemo1[3783:239611] semaphore—end,number = 100 从 Dispatch Semaphore 实现线程同步的代码可以看到： semaphore---end 是在执行完 number = 100; 之后才打印的。而且输出结果 number 为 100。这是因为异步执行不会做任何等待，可以继续执行任务。异步执行将任务1追加到队列之后，不做等待，接着执行dispatch_semaphore_wait方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到dispatch_semaphore_signal之后，总信号量，此时 semaphore == 1，dispatch_semaphore_wait方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印semaphore---end,number = 100。这样就实现了线程同步，将异步执行任务转换为同步执行任务。 6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。 下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。 场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。 6.2.1 非线程安全（不使用 semaphore）先来看看不考虑线程安全的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 非线程安全：不使用 semaphore * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票 */- (void)initTicketStatusNotSave &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"semaphore---begin"); self.ticketSurplusCount = 50; // queue1 代表北京火车票售卖窗口 dispatch_queue_t queue1 = dispatch_queue_create("net.bujige.testQueue1", DISPATCH_QUEUE_SERIAL); // queue2 代表上海火车票售卖窗口 dispatch_queue_t queue2 = dispatch_queue_create("net.bujige.testQueue2", DISPATCH_QUEUE_SERIAL); __weak typeof(self) weakSelf = self; dispatch_async(queue1, ^&#123; [weakSelf saleTicketNotSafe]; &#125;); dispatch_async(queue2, ^&#123; [weakSelf saleTicketNotSafe]; &#125;);&#125;/** * 售卖火车票(非线程安全) */- (void)saleTicketNotSafe &#123; while (1) &#123; if (self.ticketSurplusCount &gt; 0) &#123; //如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@"%@", [NSString stringWithFormat:@"剩余票数：%d 窗口：%@", self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; else &#123; //如果已卖完，关闭售票窗口 NSLog(@"所有火车票均已售完"); break; &#125; &#125;&#125; 输出结果（部分）： 2018-03-14 16:13:29.568246+0800 GCDDemo1[3911:246879] currentThread—&lt;NSThread: 0x60400007f480&gt;{number = 1, name = main}2018-03-14 16:13:29.568413+0800 GCDDemo1[3911:246879] semaphore—begin2018-03-14 16:13:29.568747+0800 GCDDemo1[3911:246935] 剩余票数：48 窗口：&lt;NSThread: 0x600000477100&gt;{number = 3, name = (null)}2018-03-14 16:13:29.568802+0800 GCDDemo1[3911:246938] 剩余票数：49 窗口：&lt;NSThread: 0x60400026f880&gt;{number = 4, name = (null)}2018-03-14 16:13:29.770884+0800 GCDDemo1[3911:246938] 剩余票数：47 窗口：&lt;NSThread: 0x60400026f880&gt;{number = 4, name = (null)}2018-03-14 16:13:29.770884+0800 GCDDemo1[3911:246935] 剩余票数：46 窗口：&lt;NSThread: 0x600000477100&gt;{number = 3, name = (null)}2018-03-14 16:13:29.975337+0800 GCDDemo1[3911:246938] 剩余票数：44 窗口：&lt;NSThread: 0x60400026f880&gt;{number = 4, name = (null)} … 可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。 6.2.2 线程安全（使用 semaphore 加锁）考虑线程安全的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 线程安全：使用 semaphore 加锁 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票 */- (void)initTicketStatusSave &#123; NSLog(@"currentThread---%@",[NSThread currentThread]); // 打印当前线程 NSLog(@"semaphore---begin"); semaphoreLock = dispatch_semaphore_create(1); self.ticketSurplusCount = 50; // queue1 代表北京火车票售卖窗口 dispatch_queue_t queue1 = dispatch_queue_create("net.bujige.testQueue1", DISPATCH_QUEUE_SERIAL); // queue2 代表上海火车票售卖窗口 dispatch_queue_t queue2 = dispatch_queue_create("net.bujige.testQueue2", DISPATCH_QUEUE_SERIAL); __weak typeof(self) weakSelf = self; dispatch_async(queue1, ^&#123; [weakSelf saleTicketSafe]; &#125;); dispatch_async(queue2, ^&#123; [weakSelf saleTicketSafe]; &#125;);&#125;/** * 售卖火车票(线程安全) */- (void)saleTicketSafe &#123; while (1) &#123; // 相当于加锁 dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER); if (self.ticketSurplusCount &gt; 0) &#123; //如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@"%@", [NSString stringWithFormat:@"剩余票数：%d 窗口：%@", self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; else &#123; //如果已卖完，关闭售票窗口 NSLog(@"所有火车票均已售完"); // 相当于解锁 dispatch_semaphore_signal(semaphoreLock); break; &#125; // 相当于解锁 dispatch_semaphore_signal(semaphoreLock); &#125;&#125; 输出结果为： 2018-03-14 16:19:17.386440+0800 GCDDemo1[4000:251186] currentThread—&lt;NSThread: 0x604000074980&gt;{number = 1, name = main}2018-03-14 16:19:17.386660+0800 GCDDemo1[4000:251186] semaphore—begin2018-03-14 16:19:17.387039+0800 GCDDemo1[4000:251241] 剩余票数：49 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}2018-03-14 16:19:17.596014+0800 GCDDemo1[4000:251240] 剩余票数：48 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}2018-03-14 16:19:17.796497+0800 GCDDemo1[4000:251241] 剩余票数：47 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}2018-03-14 16:19:18.000761+0800 GCDDemo1[4000:251240] 剩余票数：46 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}2018-03-14 16:19:18.203361+0800 GCDDemo1[4000:251241] 剩余票数：45 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)} … 2018-03-14 16:19:26.745496+0800 GCDDemo1[4000:251241] 剩余票数：3 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}2018-03-14 16:19:26.949711+0800 GCDDemo1[4000:251240] 剩余票数：2 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}2018-03-14 16:19:27.150306+0800 GCDDemo1[4000:251241] 剩余票数：1 窗口：&lt;NSThread: 0x604000467280&gt;{number = 3, name = (null)}2018-03-14 16:19:27.353673+0800 GCDDemo1[4000:251240] 剩余票数：0 窗口：&lt;NSThread: 0x604000467fc0&gt;{number = 4, name = (null)}2018-03-14 16:19:27.556782+0800 GCDDemo1[4000:251241] 所有火车票均已售完2018-03-14 16:19:27.557369+0800 GCDDemo1[4000:251240] 所有火车票均已售完 可以看出，在考虑了线程安全的情况下，使用 dispatch_semaphore机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSS订阅工具]]></title>
    <url>%2F2018%2F03%2F07%2FRSS%E8%AE%A2%E9%98%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[RSS订阅工具推荐RSS工具大全 推荐使用： Breaking （中文， 页面简洁） 将你喜欢的博客地址复制到Breaking中的搜索框中，会自动订阅，方便关注博客的动态]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（二）-- 使用next主题配置博客基本信息]]></title>
    <url>%2F2018%2F03%2F02%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89--%20%E4%BD%BF%E7%94%A8next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[在上篇文章中提到了如何免费通过github和hexo创建一个自己的博客，在此将通过next为例，演示一遍配置的过程（喜欢其他主题的可以在此绕过了） 一、前言常用命令及文件地址：部署到本地预览查看三部曲： hexo clean （清除缓存） hexo g (生成静态网页) hexo s (本地启动预览查看) 部署到git服务器上： hexo deploy 博客配置文件地址： ~/blog/_config.yml 主题配置文件地址 ~/blog/themes/next/_config.yml 后面不再重复解释 二、next主题的安装和基本配置（一）安装首先从github上clone到本地，在终端cd 到blog文件夹（即你通过Hexo init生成的根目录），然后在终端输入命令： git clone https://github.com/iissnan/hexo-theme-next themes/next 进入blog的全局配置文件：_config.yml （在blog文件夹下 /blog/_config.yml） 找到theme字段：设置为 theme: next 此时可以查看下主题是否配置成功，执行上面提到的三部曲（ 终端cd到blog文件夹 执行 hexo clean , hexo g , hexo s ）然后访问http://localhost:4000/,在本地查看效果，进行预览 （二） 基本信息的配置更多的博客和主题的配置可参考 hexo官方文档 和 next主题文档，如不想那么麻烦，可以继续往下看，下面就是我使用的一些常用的功能，足够自己使用了 1、网站标题、作者、语言在博客配置文件_config.yml中进行如下配置 # Site title: 拾忆的技术博客 subtitle: 小白的技术成长之路 description: 小白的技术成长之路 author: 拾忆 language: zh-Hans timezone: Asia/Shanghai （如不填，则表示默认电脑的时区） 这里设置标题作者名字等信息，其中language一项最好配置成zh-Hans（简体中文），（查看next主题支持哪些语言 可查看~/blog/themes/next/languages文件夹） 2、next主题的风格设置在主题配置文件_config.yml中进行如下配置 next默认有四种风格，可根据自己喜欢的样式去设置查看 # Schemes #scheme: Muse scheme: Mist #scheme: Pisces #scheme: Gemini 我这里使用的是Mist样式，其中#表示注释，使用哪种去掉前面的#即可，后不再说明 3、设置菜单选项打开主题配置文件： 先奉上我的配置方便大家去参考： menu: home: / || home categories: /categories || th about: /about || user archives: /archives || archive tags: /tags || tags #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat # Enable/Disable menu icons. menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive 其中menu表示配置菜单内容，menu_icons表示菜单图片，如需使用图片则在menu中设定值的后面加上 || 图片名 （1）常用的默认菜单项，其中home和archives两页是系统默认的就有的，其他的需要自己创建，后面会讲到 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: / 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 （2）设置菜单项的显示文本。在第一步中设置的菜单的名称并不直接用于界面上的展示。Hexo 在生成的时候将使用 这个名称查找对应的语言翻译，并提取显示文本。这些翻译文本放置在 NexT 主题目录下的 languages/{language}.yml （{language} 为你所使用的语言）。 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 languages/zh-Hans.yml，在 menu 字段下添加一项： menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 （3）设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字,去掉前缀icon-(或使用图标库中的图片名称)。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。next主题默认集成了识别Font Awesome图片的方式，只需要在里面找到想要图标的名称，就可以拿过来使用 # Enable/Disable menu icons. menu_icons: enable: true # Icon Mapping. home: home about: user categories: th tags: tags archives: archive 请注意键值（如 home）的大小写要严格匹配 4、创建上述菜单选项中对应的页面（1）分类页面 终端中cd 进入blog文件夹，执行 hexo new page &quot;categories&quot; 然后在~/blog/source 文件夹中即可看到categories文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）： --- title: 分类 （title可以自定义） type: categories （记住你写的type类型，后面分类文章需要使用） --- 这时候上一步中菜单项的配置才会生效 menu: home: / archives: /archives categories: /categories 这时候如运行本地查看会发现打开后没有任何东西，下面会告诉大家使用方法 （2）标签页面 同分类界面相同，终端中cd 进入blog文件夹，执行 hexo new page &quot;tags&quot; 然后在~/blog/source 文件夹中即可看到tags文件夹，打开里面的index.md文件，设置如下（注意：后面要加空格）： --- title: 标签 （title可以自定义） type: tags （记住你写的type类型，后面分类文章需要使用） --- 运行打开后同样什么都不会有 （3）关于页面 同理，打开index.md文件后，只需要配置标题即可 --- title: 自我介绍 date: 2018-02-28 17:11:54 --- 然后下面填写正文即可（这是我使用的方式，但是“关于”界面也可以使用其他方式配置，如配置个链接等，这里大家自行百度即可） 5、给文章添加分类和标签首先创建一个文章，上篇文章末尾有讲到，终端cd 进入blog文件夹，执行 hexo new &quot;文章名字&quot;，打开文章（在~/blog/source/_posts文件夹下）,然后进行如下配置： --- title: 标题 date: 2018-03-02 09:36:14 tags: [blog] （注意：使用[]，将需要添加的标签写进去，多个标签用,分隔，categories同理） categories: [blog] --- 保存，此时再去运行查看，点击分类和标签页面就会看到自己的文章了，不再是空的了 但是经过上述操作，发现每创建一篇文章都要在上面去加标签等字段，如果后期功能多的话，可能会要加很多字段，比较麻烦，这里有个比较相对容易的方式不用每次都去添加那些字段首先打开文件 ~/blog/scaffolds/post.md ,进行如下配置： --- title: {{ title }} date: {{ date }} tags: {{ tags }} categories: --- 你会发现，之后再创建文章时，文章上方会自动添加这些字段 6.修改作者头像并旋转打开主题配置文件，修改字段 avatar， 值设置成头像的链接地址 将头像放置主题目录下的 source/uploads/ （新建 uploads 目录若不存在）配置为： avatar: /uploads/avatar.png 或者 放置在 source/images/ 目录下配置为： avatar: /images/avatar.png 或直接放上链接，如：avatar: http://example.com/avatar.png 此时头像设置完成，如需实现旋转效果则按如下过程： 打开~\blog\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; } img:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 7.头像下方添加自己的github等信息打开主题配置文件，找到social字段，配置如下，大家可根据自己情况去配置，图片的使用方法同菜单栏一样 social: GitHub: https://github.com/username || github #E-Mail: #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype social_icons: enable: true #icons_only: false #transition: false GitHub: github 8.给站点添加友情链接功能打开主题配置文件，进行如下配置： links_title: 友情链接 links: #百度: http://www.baidu.com/ #新浪: http://example.com/ 三、next主题的高级配置和一些炫酷的效果（一） 增加评论系统百度了一下最新的消息，当前版本的next主题中已经内置支持了各种各样的评论系统，但由于政策的原因（需要实名评论），导致大多数的评论插件都已经失效了，而国外的一些加载比较慢。 这里附上gitment的评论集成方式集成流程 gitment（依托于github issue，能够自己管理，而且被墙的概率小），不过兼容性不太好（需要chrome内核才行），本人使用的gitment，有一个小问题，就是每次发布文章时需要登录下自己的github账号去初始化一下评论，评论功能才能使用，否则会提示“未开放评论” Hypercomments 是国外的一个第三方评论平台 多说 在2017年06月01日就关闭评论服务了 网易云跟贴 2017年08月01日也停止服务了 来必力 (韩国人弄的)总是乱码 DISQUS 外国的，加载慢 （二） 隐藏网页底部powered By Hexo / 强力驱动打开主题配置文件，找到如下图位置，将powered设置为 false，theme下的enable 设置为 false （三） 设置首页文章列表不显示全文(只显示预览) 进入hexo博客项目的themes/next目录 打开_config.yml文件 搜索”auto_excerpt”,找到如下部分： # Automatically Excerpt. Not recommand. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: false length: 150 把enable改为对应的false改为true，length设置下，然后hexo d -g，再进主页，问题就解决了！ （四） 增加本地搜索功能添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： npm install hexo-generator-searchdb --save 编辑博客配置文件，新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： # Local search local_search: enable: true （五） 给 hexo next 主题加上背景图片给 hexo next 加上背景图片，只需要在 themes\next\source\css_custom\custom.styl 文件中添加几行代码： 12345678910111213@media screen and (min-width:1200px) &#123; body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; &#125; #footer a &#123; color:#eee; &#125;&#125; repeat、attachment、position就是调整图片的位置，不重复出现、不滚动等等。 完成这一步其实背景就会自动更换了，但是会出现一个问题，因为next主题的背景是纯透明的，这样子就造成背景图片的影响看不见文字，这对于博客来说肯定不行。 那么就需要调整背景的不透明度了。同样是修改themes\next\source\css\ _custom\custom.styl文件。在后面添加如下代码 1234567.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px;&#125; background: #fff; 白色 opacity: 0.8;不透明度 （六） 其他炫酷效果可参考 hexo的next主题个性化教程:打造炫酷网站]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（一）-- 使用Hexo&GitHub免费快速搭建]]></title>
    <url>%2F2018%2F03%2F01%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89--%20%E4%BD%BF%E7%94%A8Hexo%26GitHub%E5%85%8D%E8%B4%B9%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[经过两天的折腾，终于搞定了属于自己的第一个博客的搭建，在此期间踩了许多坑，现总结一下帮助各位能够更方便去搭建自己的博客。先贴上成果 拾忆的博客 百度参考了各路大神的博客文章最后进行的总结，望各路大神不要介意哦~ 因为本人长期使用mac电脑，故本篇文章只在mac系统的基础上去实现功能，使用Windows系统需要自行参考，其原理是一样的。 这是本人写的第一篇文章，可能会看到和其他的许多文章有相似之处，请大家自动忽略(￣▽￣)~* ，全文纯手打，旨在帮助大家更方便的实现搭建过程，大家不喜勿喷哦~ 一、引子1.搭建博客的原因 曾经用过印象笔记，有道笔记等工具来记录文章，但用起来总是感觉有或多或少的问题，不如用博客看的更直观 可以随心发表，改造外观，功能 拥有一个自己的博客网站，感觉更爽 希望更多的人可以看到自己写的文章 2.整个过程使用的时间 最开始百度参考了各路大神的文章，每篇文章都会有或多或少的缺陷，自己又踩了许多坑才完成 用了大概两天的时间，完成了博客的搭建和主题的修改 3.环境配置 mac系统，sublime编辑器 （暂时使用到的） github账号，hexo框架配置，next主题 （下面会提供配置方式） 4.搭建方式 使用hexo框架进行网站的构建，然后部署到免费的github上 二、GitHub配置 登陆 https://github.com/ ，没有账号的就去注册一个，记住自己的用户名 主页中点击右上角自己的图标，点击your profile 点击repositories，新建一个 Repository name （填自己的名字） http://yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了),下图中报错是因为我已经用过了这个名字，大家填写自己的名字不会遇到这个问题，然后点击create repository进行下一步 点击自己的这个repository，然后找到settings 下拉找到GitHub Pages, 其中上面红框中的即为你的博客地址，下面红色框中可以进去选择自己的主题样式, 此时github中的基本配置已经完成 如第一次进入，可能会不显示博客地址，如下图，则可以先选择github自带的主题样式，Choose a theme 按钮，再回来后就能够看到了(注意：在save按钮左边那项要显示为master branch才表示正确) 三、环境配置 安装 Node.js 安装完成后终端输入 node -v npm -v 查看版本号，如存在则表明配置成功 mac系统：下载Xcode会自带Git环境，Windows用户需要自行下载Git 安装完成后，通过git命令查看自己的用户名和邮箱是否和自己github中的一致，如不一致请自行更改，如查询到多个用户名须删除没用的用户名，如查询后没有任何反应则表明还没有配置用户名，用下面的修改或者添加用户名命令即可，如提示其他之类的可先执行命令 git config，然后再执行以下命令即可成功,附查看和更改命令（其他命令可自行百度查找）： 查看用户名： git config --global user.name 查看邮箱： git config --global user.email 删除用户名 git config --global --unset user.name 要删的用户名 增加用户名 git config —global —add user.name 新加的用户名 修改用户名 git config --global user.name 用户名 修改邮箱 git config --global user.email 邮箱 终端中输入 npm install -g hexo-cli(如提示无权限即下图红色框中permission denied，则输入sudo npm install -g hexo-cli,后输入电脑密码enter即可) 这个过程会比较久，如果出现WARN错误可以忽略。我记得当时，每次都会出现说有一个依赖包已经不更新，这个不影响。执行完成后，使用 hexo -v 查看是否安装成功，如下图所示，即表明已经成功安装上 四、网站代码以及设置 在桌面上创建一个文件夹，名字自定义如：hexo,终端cd 进入hexo文件夹 输入hexo init blog (如出现warn错误可忽略，不影响) _config.yml, 网站的配置信息，可以在此配置中配置大部分的参数 source，资源文件夹是存放用户资源的地方。除 posts 文件夹之外，开头命名为 (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去 themes，主题 文件夹。Hexo 会根据主题来生成静态页面。 等待提示Start blogging with Hexo，就是安装成功了 文件夹中自带一篇文章“Hello World” 命令行cd进入blog目录下 输入hexo g，生存静态文件 输入hexo s，启动服务器。默认情况下，访问网址为： http://localhost:4000/ 此时服务开启，如需关闭Ctrl+ C 注：hexo s 命令开启的是本地服务，开启后，则可以使用上述地址访问，如关闭，则上述地址访问不到，本功能旨在用来检查修改的配置是否成功，如打开查看后发现没有问题则可以部署到服务器上，之后再用你的博客地址访问即可看到最新的设置效果。 如上传服务器之后立即查看博客可能没有立即变化，可尝试多刷新几次或重新打开浏览器即可 新打开一个终端，输入：ssh-keygen -t rsa -C “Github的注册邮箱地址” 一路enter过来，中间有的问题是选y/n的，选y即可，最后得到信息中找到这句话： Your public key has been saved in /Users/zjjk/.ssh/id_rsa.pub. 找到该文件(上句中in 后面即为该文件的地址)，打开（使用sublime text或其他编辑器）,Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：github.com/settings/ssh 一步步操作：New SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 注：此过程是生成ssh key，如后续再次执行此命令时，则需要把新生成的SSH key再配置到github中，因为新生成的SSH key会覆盖之前的，如不去github中替换会导致后续上传git服务器过程中失败 五、博客网站配置信息 进入blog文件夹，用sublime打开_config.yml文件，此文件为博客的配置信息，在此修改参数。（特别注意：每个参数的后面都要加个空格） 按照自己的信息进行基础设置 title: 拾忆的博客 subtitle: 小白的技术成长之路 description: 小白的技术成长之路 author: 拾忆 language: zh-CN timezone: Asia/Shanghai 在_config.yml文件中找到 deploy配置处（一般在最下面，默认的显示可能不全，需按照下方示例自己添加）, username替换成你自己的username, repository的地址为你在github中创建的那个项目的地址，可去github中复制 deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 保存完毕。 各类主题的配置信息，要在主题文件夹内的_config.yml上进行配置！后续会以next主题为例进行示范，此处可忽略。 六、发表文章 终端 cd 进入blog文件夹下，输入hexo new &quot;Hello blog&quot;(Hello blog为你的文章名，可自定义) 打开返回的文件地址，打开文件（也可在blog文件夹下 source/_posts/Hello blog.md 中找到你刚才创建的文件） 文章内容采用Markdown语法进行编辑，需要用相关软件才能打开这个文件，本人使用的软件为MacDown mac版, 大家可根据自己习惯下载喜欢的工具(附：Markdown语法使用说明) 打开文件编辑 --- title: Hello blog date: --- 只输入title字段即可，后续其他字段可根据主题再添加（注意：title后面需加空格） 打开终端执行以下步骤: cd 进入blog 文件夹 $ hexo clean INFO Deleted database. INFO Deleted public folder. $ hexo generate INFO Start processing INFO Files loaded in 1.48 s ... INFO 29 files generated in 4.27 s $ hexo server INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 此处三步是进行本地配置完成后，在本地打开查看刚刚修改的配置是否修改成功，三处命令也可这样写 hexo clean hexo g hexo s 打开 http://localhost:4000/后检查，如没有任何问题可以部署到服务器上 $ hexo deploy INFO Deploying: git 此时可能会出现 error deployer not found:git 的错误，输入以下代码 npm install hexo-deployer-git --save(如提示无权限错误则输入sudo npm install hexo-deployer-git –-save，后输入电脑密码enter即可) 再次执行 hexo deploy 其中，可能会出现github登录界面，正常填写就行(这里我一直登陆着github，暂时没有遇到) 完成，终端可Ctrl+C关闭本地服务，然后打开 username.github.io 即可访问自己的博客（username为自己的github的用户名） 七、主题设置主题设置中，最好玩的就是尝试各式各样的主题啦！因本人喜欢next主题的风格，所以会在下篇文章中以next主题为例，走一遍发布文章和配置博客各种信息的流程，下面是其他的一些主题，大家可根据自己喜欢的样式去选择主题下载配置，一般的主题配置都会在其相应的github中说明 官方hexo主题大全，里面有许多主题都能尝试一下。 在这里推荐几个主题： next官网,Git(我用的就是这个啦，十分推荐！） Material官网，Git 主题配置，首先要下载主题，到相应的Git链接 下载完以后将文件解压缩后放到blog中的themes文件夹中 修改主题文件夹名称，将其改为 next(名称为你的主题的名称，可自定义，无硬性要求，下以next为例) 。 然后打开配置文件（/blog/_config.yml），找到 theme 字段，并将其值更改为 next(你刚才自定义的名称, 注意theme后加空格)，保存关闭 接下来，打开主题相应的博客中的文档说明，对比“主题”中的_config.yml（ /blog/themes/next/_config.yml ），针对自己需要的功能进行相关设置 有关设置中的图片，统一放到主题文件夹(/next/)内\source\img。在设置中，用”/img/xigua.png”类似格式进行图片设置。 设置时切记 : 后面要加一个空格。这个坑有点恼人~ 最后再重新进行一次，hexo clean,hexo g,hexo s,hexo deploy 整个博客就完成主题修改啦 八、总结 用了两天的时间，完成的博客的搭建，又花了一天时间来编写此篇文章，全文纯手打，写到这里真的好累啊~ 看着别人的文章一路搭建下来中间还是会遇到很多问题，于是各种百度解决，故在此奉上此文，我遇到的坑这里都明确的解决了，大家也一样，可能会遇到各种不同的问题，百度去一个一个的解决就好了（万能的百度啊~~~） 编写文章用了一遍Markdown的语法，感觉还可以 拾忆的博客 后续会陆续编写更多的文章，欢迎大家订阅哦~]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
